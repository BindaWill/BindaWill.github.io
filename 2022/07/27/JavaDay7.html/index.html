<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Java基础Day7-Java高级类特性 - 火星环游日记</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础Day7-Java高级类特性">
<meta property="og:url" content="http://yoursite.com/2022/07/27/JavaDay7.html/index.html">
<meta property="og:site_name" content="火星环游日记">
<meta property="og:description" content="多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java12.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java51.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java52.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java53.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java55.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java56.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java57.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java58.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java59.PNG">
<meta property="article:published_time" content="2022-07-27T12:12:13.000Z">
<meta property="article:modified_time" content="2022-08-10T14:01:44.088Z">
<meta property="article:author" content="非酋囧菌">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1660569633945">
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="mdui-drawer-body-left">
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/logo/a1.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="非酋囧菌" class="mdui-btn mdui-btn-icon"><img src="/images/logo/a3.jpg" alt="非酋囧菌"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="非酋囧菌">
            <img src="/images/logo/a3.jpg" alt="非酋囧菌" alt="非酋囧菌">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>59</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/me.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/py.html" title="我的基友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的基友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1161831210" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/33638990" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 非酋囧菌
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
          <img data-src="/images/JavaStudyData/banner.jpg" data-sizes="auto" alt="Java基础Day7-Java高级类特性" class="lazyload">
          <h1>Java基础Day7-Java高级类特性</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年07月27日</a>
    <a><i class="nexmoefont icon-areachart"></i>4.2k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 18 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</p>
<a id="more"></a>
<h2 id="学习思维导图"><a href="#学习思维导图" class="headerlink" title="学习思维导图"></a>学习思维导图</h2><p><img data-sizes="auto" data-src="/images/JavaStudyData/java11.jpg" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java12.jpg" alt="" class="lazyload"></p>
<h3 id="4-1-面向对象特征之二：继承"><a href="#4-1-面向对象特征之二：继承" class="headerlink" title="4.1  面向对象特征之二：继承"></a>4.1  面向对象特征之二：继承</h3><ul>
<li>为描述和处理个人信息，定义类Person:</li>
</ul>
<table>
<thead>
<tr>
<th>Person</th>
<th>*</th>
</tr>
</thead>
<tbody><tr>
<td>name : String</td>
<td>-</td>
</tr>
<tr>
<td>age : int</td>
<td>-</td>
</tr>
<tr>
<td>+getInfo() : String</td>
<td>-</td>
</tr>
</tbody></table>
<pre><code>public class Person {
public String name;
public int age;
public String getInfo()   
 {...}
 }</code></pre><h6 id="继-承-1"><a href="#继-承-1" class="headerlink" title="继  承(1)"></a>继  承(1)</h6><ul>
<li>为描述和处理学生信息，定义类Student:</li>
</ul>
<table>
<thead>
<tr>
<th>Student</th>
<th>*</th>
</tr>
</thead>
<tbody><tr>
<td>name : String</td>
<td>-</td>
</tr>
<tr>
<td>age : int</td>
<td>-</td>
</tr>
<tr>
<td>school : String</td>
<td>-</td>
</tr>
<tr>
<td>getInfo() : String</td>
<td>-</td>
</tr>
</tbody></table>
<pre><code> public class Student {
     public String name;
     public int age;
     public String school;

 public String getInfo(){...}
}</code></pre><p><img data-sizes="auto" data-src="/images/JavaStudyData/java51.PNG" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java52.PNG" alt="" class="lazyload"></p>
<h5 id="继-承-2"><a href="#继-承-2" class="headerlink" title="继  承(2)"></a>继  承(2)</h5><ul>
<li>通过继承，简化Student类的定义:</li>
</ul>
<table>
<thead>
<tr>
<th>Person</th>
<th>*</th>
</tr>
</thead>
<tbody><tr>
<td>+name : String</td>
<td>-</td>
</tr>
<tr>
<td>age : int</td>
<td>-</td>
</tr>
<tr>
<td>birthDate : Date</td>
<td>-</td>
</tr>
<tr>
<td>getInfo() : String</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Student</th>
<th>*</th>
</tr>
</thead>
<tbody><tr>
<td>school : String</td>
<td>-</td>
</tr>
</tbody></table>
<pre><code>public class Person {
    public String name;
    public int age;
public String getInfo() {...}
}

public class Student extends Person{
    public String school;
 }</code></pre><ul>
<li><strong>Student类继承了父类Person的所有属性和方法，并增加了一个属性school。Person中的属性和方法,Student都可以利用。</strong></li>
</ul>
<h4 id="继-承-3"><a href="#继-承-3" class="headerlink" title="继  承(3)"></a>继  承(3)</h4><ul>
<li><p>为什么要有继承？</p>
<ul>
<li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
</ul>
</li>
<li><p>此处的多个类称为子类，单独的这个类称为父类（基类或超类）。可以理解为:“子类 is a 父类”</p>
</li>
</ul>
<blockquote>
<p>把共性的东西抽出来形成父类，实际需求的子类再继承父类的基础上写自己特有代码即可。</p>
</blockquote>
<ul>
<li>类继承语法规则:<ul>
<li>class Subclass extends Superclass{ }</li>
</ul>
</li>
</ul>
<h4 id="继-承-4"><a href="#继-承-4" class="headerlink" title="继  承(4)"></a>继  承(4)</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java53.PNG" alt="" class="lazyload"></p>
<ul>
<li><p>作用：</p>
<ul>
<li><p>继承的出现提高了代码的复用性。</p>
</li>
<li><p>继承的出现让类与类之间产生了关系，提供了多态的前提。</p>
</li>
<li><p>不要仅为了获取其他类中某个功能而去继承</p>
</li>
</ul>
</li>
</ul>
<h4 id="类的继承-5"><a href="#类的继承-5" class="headerlink" title="类的继承 (5)"></a>类的继承 (5)</h4><blockquote>
<p>子类继承了父类，就继承了父类的方法和属性。</p>
</blockquote>
<blockquote>
<p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。</p>
</blockquote>
<blockquote>
<p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。</p>
</blockquote>
<h5 id="关于继承的规则："><a href="#关于继承的规则：" class="headerlink" title="关于继承的规则："></a>关于继承的规则：</h5><p>子类不能直接访问父类中私有的(private)的成员变量和方法。<br>！<a href="/images/JavaStudyData/java54.PNG"></a></p>
<h4 id="类的继承-6"><a href="#类的继承-6" class="headerlink" title="类的继承 (6)"></a>类的继承 (6)</h4><ul>
<li>Java只支持单继承，不允许多重继承<ul>
<li>一个子类只能有一个父类</li>
<li>一个父类可以派生出多个子类</li>
</ul>
</li>
</ul>
<pre><code>class SubDemo extends Demo{ }   //ok
class SubDemo extends Demo1,Demo2...//error</code></pre><p><img data-sizes="auto" data-src="/images/JavaStudyData/java55.PNG" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java56.PNG" alt="" class="lazyload"></p>
<h5 id="单继承举例"><a href="#单继承举例" class="headerlink" title="单继承举例"></a>单继承举例</h5><p><img data-sizes="auto" data-src="/images/JavaStudyData/java57.PNG" alt="" class="lazyload"></p>
<p>1.(1)定义一个ManKind类，包括<br>成员变量int sex和int salary；<br>方法void manOrWorman()：根据sex的值显示“man”(sex==1)或者“women”(sex==0)；<br>方法void employeed()：根据salary的值显示“no job”(salary==0)或者“ job”(salary!=0)。<br>   (2)定义类Kids继承ManKind，并包括<br>成员变量int yearsOld；<br>方法printAge()打印yearsOld的值。<br>   (3)在Kids类的main方法中实例化Kids的对象someKid，用该对象访问其父类的成员变量及方法。</p>
<pre><code>  /*
  *这是一个描述成员的类
  */
  public class ManKind {
  int sex;  //性别
  int salary;  //薪酬


//这是一个打印输出性别的方法
public void manOrWorman(){
    if (sex==1){
        System.out.println(&quot;man&quot;);
    }else {
        System.out.println(&quot;women&quot;);
    }

}
//这是一个打印输出是否有工作的方法
public void employeed(){
    if (salary==0){
        System.out.println(&quot;no job&quot;);
    }else {
        System.out.println(&quot;job&quot;);
    }
   }
 }

  /**
  * 这是一个继承ManKind的子类
  */
  public class Kids extends ManKind {

  int yearsOld; //年龄
  public static void main(String[] args) {

    Kids somekid = new Kids();//实例化Kids的对象someKid
    somekid.yearsOld= 12;
    somekid.sex=1;
    somekid.salary=0;

    somekid.manOrWorman();  //访问父类manOrWorman方法
    somekid.printAge();  // 访问printAge方法
    somekid.employeed();// 访问父类employeed方法



}
 ////这是一个打印输出年龄的方法
public void printAge(){

    System.out.println(&quot;年龄为&quot;+yearsOld);//
   }
 }</code></pre><hr>
<h3 id="4-2-方法的重写-override"><a href="#4-2-方法的重写-override" class="headerlink" title="4.2  方法的重写(override)"></a>4.2  方法的重写(override)</h3><ul>
<li><p>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
</li>
<li><p>要求：</p>
<ul>
<li>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。</li>
<li>重写方法不能使用比被重写方法更严格的访问权限。</li>
<li>重写和被重写的方法须同时为static的，或同时为非static的</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
</li>
<li><p>子类重写父类方法，只是重写编写方法体的代码,如果父类的方法是public，子类重写的时候就不能使用缺省以下。</p>
</li>
</ul>
<h5 id="重写方法举例-1"><a href="#重写方法举例-1" class="headerlink" title="重写方法举例(1)"></a>重写方法举例(1)</h5><pre><code>public class Person {
    public String name;
    public int age;
public String getInfo() {
      return &quot;Name: &quot;+ name + &quot;\n&quot; +&quot;age: &quot;+ age;
}
}

public class Student extends Person {
    public String school;
  public String getInfo() {       //重写方法
        return  &quot;Name: &quot;+ name + &quot;\nage: &quot;+ age + &quot;\nschool: &quot;+school;
  }

public static void main(String args[]){
       Student s1=new Student();
       s1.name=&quot;Bob&quot;;
       s1.age=20;
       s1.school=&quot;school2&quot;;
       System.out.println(s1.getInfo());   //Name:Bob  age:20  school:school2
}
}</code></pre><h4 id="对象方法调用"><a href="#对象方法调用" class="headerlink" title="对象方法调用"></a>对象方法调用</h4><pre><code>Person p1=new Person();
p1.getInfo();</code></pre><ul>
<li>调用Person类的getInfo()方法</li>
</ul>
<pre><code>Student s1=new Student();
s1.getInfo();</code></pre><ul>
<li>调用Student类的getInfo()方法</li>
</ul>
<blockquote>
<p>这是一种“多态性”：同名的方法，用不同的对象来区分调用的是哪一个方法。</p>
</blockquote>
<h5 id="重写方法举例-2"><a href="#重写方法举例-2" class="headerlink" title="重写方法举例(2)"></a>重写方法举例(2)</h5><pre><code>class Parent {
  public void method1() {
}
}

class Child extends Parent {
      private void method1() {  
    }  
//非法，子类中的method1()的访问权限private比被覆盖方法的访问权限public弱
}

public class UseBoth {
  public static void main(String[] args) {
        Parent p1 = new Parent();
        Child p2 = new Child();
        p1.method1();
        p2.method1();
}
}</code></pre><ul>
<li><p>方法的重载：一个类可以用多个同名的方法。</p>
</li>
<li><p>方法的重写：子类可以重写父类的方法，覆盖父类方法</p>
</li>
</ul>
<hr>
<h3 id="4-3-四种访问权限修饰符"><a href="#4-3-四种访问权限修饰符" class="headerlink" title="4.3 四种访问权限修饰符"></a>4.3 四种访问权限修饰符</h3><p><strong>Java权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类对象成员的访问权限。</strong></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>子类</th>
<th>任何地方</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default(缺省)</td>
<td>Yes</td>
<td>Yse</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yse</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yse</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<ul>
<li><strong>对于class的权限修饰只可以用public和default。</strong><ul>
<li><strong>public类可以在任意地方被访问。</strong></li>
<li><strong>default类只可以被同一个包内部的类访问。</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>如果子类和父类在同一个包下，那么对于父类的成员修饰符只要不是私有的private那就都可以使用。</p>
</blockquote>
<blockquote>
<p>如果子类和父类不在同一个包下，那么子类只能使用父类中protected和public修饰的成员变量</p>
</blockquote>
<h4 id="访问控制举例"><a href="#访问控制举例" class="headerlink" title="访问控制举例"></a>访问控制举例</h4><pre><code>class Parent{
    private int f1 = 1;
    int f2 = 2;
    protected  int f3 = 3;
    public  int f4 = 4;

private  void  fm1(){
    System.out.println(&quot;in fm1() f1=&quot; + f1);
}
void fm2() {
    System.out.println(&quot;in fm2() f2=&quot; + f2);
}
protected  void  fm3() {
    System.out.println(&quot;in fm3() f3=&quot; + f3);
}
public void fm4() {
    System.out.println(&quot;in fm4() f4=&quot; + f4);
}
}

class Child extends Parent{
//设父类和子类在同一个包内
      private int c1 = 21;
      public  int c2 = 22;     
  private void cm1(){
  System.out.println(&quot;in cm1() c1=&quot; + c1);
}
  public  void cm2(){
  System.out.println(&quot;in cm2() c2=&quot; + c2);
}

  public static void main(String args[]){
        int i;
        Parent  p = new Parent();        
        i = p.f2;            //    i = p.f3;        i = p.f4;                p.fm2();         //    p.fm3();    p.fm4();        
        Child  c = new Child();
        i = c.f2;            //    i = c.f3;        i = c.f4;        
        i = c.c1;            //    i = c.c2;        
        c.cm1();        // c.cm2();    c.fm2();   c.fm3();   c.fm4()
}
}</code></pre><h4 id="访问控制分析"><a href="#访问控制分析" class="headerlink" title="访问控制分析"></a>访问控制分析</h4><p>父类Parent和子类Child在同一包中定义时：</p>
<table>
<thead>
<tr>
<th>子类对象可以访问的数据</th>
<th>子类的对象可以调用的方法</th>
</tr>
</thead>
<tbody><tr>
<td>f2_default</td>
<td>fm2()_default</td>
</tr>
<tr>
<td>f3_protected</td>
<td>fm3()_ protected</td>
</tr>
<tr>
<td>f4_public</td>
<td>fm4()_ public</td>
</tr>
<tr>
<td>c1_private</td>
<td>cm1()_private</td>
</tr>
<tr>
<td>c2_public</td>
<td>cm2()_public</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-关键字super"><a href="#4-4-关键字super" class="headerlink" title="4.4  关键字super"></a>4.4  关键字super</h3><ul>
<li>在Java类中使用super来调用父类中的指定操作：<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造方法中调用父类的构造器</li>
</ul>
</li>
<li>注意：<ul>
<li>尤其当子父类出现同名成员时，可以用super进行区分</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用super，子类可以调用子类之上所有父类层级</p>
</blockquote>
<pre><code>public class Kk extends Kid{

    public void test(){
      super.selary = 1;
      //可以使用super向上追溯父类的父类，当然可以一致向上追溯，如果有那么多个层级的话
      super.yearOld = 12;
      //可以使用super直接追溯父类的成员变量
      super.setYearOld();
      //可以使用super直接追溯父类的成员方法
      super.getSelary();
      //可以使用super向上追溯父类的父类的成员方法，当然可以一致向上追溯，如果有那么多个层级的话
    }
}</code></pre><h4 id="关键字super举例"><a href="#关键字super举例" class="headerlink" title="关键字super举例"></a>关键字super举例</h4><pre><code>class Person {
      protected String name=&quot;张三&quot;;
    protected int age;
    public String getInfo() {
    return &quot;Name: &quot; + name + &quot;\nage: &quot; + age;
    }
}
class Student extends Person {
    protected String name = &quot;李四&quot;;
      private String school = &quot;New Oriental&quot;;
  public String getSchool(){
    return school;
}
public String getInfo() {
    return super.getInfo() +&quot;\nschool: &quot; +school;
}
}


public class TestStudent{

    public static void main(String[] args){
        Student st = new Student();
        System.out.println(st.getInfo());
    }
}</code></pre><hr>
<h4 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h4><ul>
<li><p>子类中所有的构造器默认都会访问父类中空参数的构造器</p>
</li>
<li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行</p>
</li>
<li><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p>
<p>  Kids kk = new Kids();</p>
</li>
</ul>
<blockquote>
<p>子类在创建对象时，new Kid()是在调用Kids类的默认无参构造方法，在这个过程中就会使用到父类的无参构造</p>
</blockquote>
<blockquote>
<p>当存在显式的构造方法时，类就没有默认的无参构造了，而是要使用显式的构造</p>
</blockquote>
<blockquote>
<p>在父类只有有参构造器可以使用时，子类必须显式的构建一个构造来调用父类的有参构造，并且调用父类的构造方法要写在第一行</p>
</blockquote>
<h4 id="调用父类构造器举例"><a href="#调用父类构造器举例" class="headerlink" title="调用父类构造器举例"></a>调用父类构造器举例</h4><pre><code>public class Person {

   private String name;
   private int age;
     private Date birthDate;


   public Person(String name, int age, Date d) {
     this.name = name;
       this.age = age;
        this.birthDate = d;
   }

      public Person(String name, int age) {
     this(name, age, null);
      }
      public Person(String name, Date d) {
         this(name, 30, d);
     }
      public Person(String name) {
         this(name, 30);
      }
   }</code></pre><h4 id="调用父类构造器举例-1"><a href="#调用父类构造器举例-1" class="headerlink" title="调用父类构造器举例"></a>调用父类构造器举例</h4><pre><code>public class Student extends Person {
  private String school;

  public Student(String name, int age, String s) {
    super(name, age);
       school = s;
  }
  public Student(String name, String s) {
    super(name);
      school = s;
  }
  public Student(String s) {
  // 编译出错: no super(),系统将调用父类无参数的构造方法。
       school = s;
     }</code></pre><p>   }</p>
<h4 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h4><table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类的方法</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器首行</td>
</tr>
<tr>
<td>4</td>
<td>特殊</td>
<td>表示当前对象</td>
<td>无此概念</td>
</tr>
</tbody></table>
<blockquote>
<p>多层继承，super访问的父级的方法</p>
</blockquote>
<blockquote>
<p>在子类中通过this或者super调用构造器，只能使用一个，因为二者都要占据首行</p>
</blockquote>
<hr>
<h3 id="4-5简单类对象的实例化过程"><a href="#4-5简单类对象的实例化过程" class="headerlink" title="4.5简单类对象的实例化过程"></a>4.5简单类对象的实例化过程</h3><p><img data-sizes="auto" data-src="/images/JavaStudyData/java58.PNG" alt="" class="lazyload"></p>
<h4 id="4-5子类对象的实例化过程"><a href="#4-5子类对象的实例化过程" class="headerlink" title="4.5子类对象的实例化过程"></a>4.5子类对象的实例化过程</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java59.PNG" alt="" class="lazyload"></p>
<hr>
<h3 id="4-6-面向对象特征之三：多态性"><a href="#4-6-面向对象特征之三：多态性" class="headerlink" title="4.6  面向对象特征之三：多态性"></a>4.6  面向对象特征之三：多态性</h3><ul>
<li>多态性，是面向对象中最重要的概念，在java中有两种体现：<ul>
<li>方法的重载(overload)和重写(overwrite)。</li>
<li>对象的多态性   ——可以直接应用在抽象类和接口上。</li>
</ul>
</li>
</ul>
<blockquote>
<p>重载的多态：本类中的同名方法，体现相同的名称方法实现不同的逻辑。</p>
</blockquote>
<blockquote>
<p>重写的多态：子类对父类方法的覆盖，子类可以使用父类相同的方法名，覆盖掉父类的逻辑；父类的方法想修改逻辑，但是有别的代码在调用父类的方法，可考虑用子类继承父类，重写父类的方法。</p>
</blockquote>
<ul>
<li>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。<ul>
<li>若编译时类型和运行时类型不一致，就出现多态（Polymorphism）</li>
</ul>
</li>
</ul>
<h4 id="多态性-2"><a href="#多态性-2" class="headerlink" title="多态性(2)"></a>多态性(2)</h4><ul>
<li>对象的多态—在Java中,子类的对象可以替代父类的对象使用<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
</ul>
</li>
</ul>
<pre><code>Person p = new Person();
Person e = new Student(); // Person类型的变量e，指向Student类型的对象</code></pre><ul>
<li><strong>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</strong></li>
</ul>
<h4 id="多态性-3"><a href="#多态性-3" class="headerlink" title="多态性(3)"></a>多态性(3)</h4><ul>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p>
<pre><code>Student m = new Student();
m.school = “pku”;       //合法,Student类有school成员变量
Person e = new Student();
e.school = “pku”;    //非法,Person类没有school成员变量
属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</code></pre></li>
</ul>
<h4 id="虚拟方法调用-Virtual-Method-Invocation"><a href="#虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="虚拟方法调用(Virtual Method Invocation)"></a>虚拟方法调用(Virtual Method Invocation)</h4><ul>
<li><p>正常的方法调用</p>
<pre><code>Person p = new Person();
p.getInfo();
Student s = new Student();
 s.getInfo();</code></pre></li>
<li><p>虚拟方法  调用(多态情况下)</p>
<pre><code>Person e = new Student();
e.getInfo();    //调用Student类的getInfo()方法</code></pre></li>
<li><p>编译时类型和运行时类型<br>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定</p>
</li>
</ul>
<blockquote>
<p>java的方法是运行在栈内存中的，在运行方法时会动态的进栈和出栈。</p>
</blockquote>
<blockquote>
<p>当前的情况，是getInfo方法是student对象的方法。</p>
</blockquote>
<h4 id="多态小结"><a href="#多态小结" class="headerlink" title="多态小结"></a>多态小结</h4><ul>
<li><p>前提：</p>
<ul>
<li>需要存在继承或者实现关系</li>
<li>要有覆盖操作（子类重写父类方法）</li>
</ul>
</li>
<li><p>成员方法：</p>
<ul>
<li>编译时：要查看引用变量所属的类中是否有所调用的方法。</li>
<li>运行时：调用实际对象所属的类中的重写方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>成员方法的多态性，也就是动态性，必须得存在于方法的重写之上。</p>
</blockquote>
<ul>
<li><p>成员变量：</p>
<ul>
<li>不具备多态性，只看引用变量所属的类。</li>
</ul>
</li>
<li><p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果子类没有重写父类的方法，那么子类就是直接使用父类的方法；如果重写了，自己就使用自己重写后的方法。</p>
</blockquote>
<h4 id="多态性应用举例"><a href="#多态性应用举例" class="headerlink" title="多态性应用举例"></a>多态性应用举例</h4><ul>
<li><p>方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<p>  public class Test{</p>
<pre><code>  public void method(Person e) {
    //……
      e.getInfo();
  }
  public static  void main(Stirng args[]){
      Test t = new Test();
      Student m = new Student();
      t.method(m); //子类的对象m传送给父类类型的参数e
  }
}</code></pre></li>
</ul>
<blockquote>
<p>把子类看作一个特殊的父类（解耦合，多人分工合作）</p>
</blockquote>
<h4 id="多态性应用举例-1"><a href="#多态性应用举例-1" class="headerlink" title="多态性应用举例"></a>多态性应用举例</h4><ul>
<li><p>方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<pre><code>public class Test{
 public void method(Person e) {
         //……
         e.getInfo();
   }
public static  void main(Stirng args[]){
         Test t = new Test();
          Student m = new Student();
          t.method(m); //子类的对象m传送给父类类型的参数e
     }
}</code></pre></li>
</ul>
<hr>
<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><ul>
<li><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。</p>
<ul>
<li>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
<li>如果x属于类A的子类B，x instanceof  A值也为true。</li>
</ul>
</li>
</ul>
<pre><code>public class Person extends Object {…}
public class Student extends Person {…}
public class Graduate extends Person {…}
-------------------------------------------------------------------
public void method1(Person e) {
    if (e instanceof Person)
              // 处理Person类及其子类对象
      if (e instanceof Student)
              //处理Student类及其子类对象
      if (e instanceof Graduate)
              //处理Graduate类及其子类对象
}</code></pre><hr>
<h3 id="4-7-Object-类"><a href="#4-7-Object-类" class="headerlink" title="4.7  Object 类"></a>4.7  Object 类</h3><ul>
<li><p>Object类是所有Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类</p>
<pre><code>public class Person {
...
}
等价于：</code></pre><p>  public class Person extends Object {<br>  …<br>  }</p>
</li>
<li><p>例：method(Object obj){…}//可以接收任何类作为其参数</p>
<pre><code>Person o=new Person();  
method(o);</code></pre></li>
</ul>
<h4 id="Object类中的主要方法"><a href="#Object类中的主要方法" class="headerlink" title="Object类中的主要方法"></a>Object类中的主要方法</h4><table>
<thead>
<tr>
<th>NO.</th>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>public Objext()</td>
<td>构造</td>
<td>构造方法</td>
</tr>
<tr>
<td>2</td>
<td>public boolean equals（Object obj）</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>3</td>
<td>public int hashCodes（）</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>4</td>
<td>public String toString（）</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody></table>
<blockquote>
<p>Object类是所有Java类的父类，子类可以执行父类的方法，所有类的对象都可以执行object类中方法。</p>
</blockquote>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>非酋囧菌<br>
    <strong>本文链接：</strong><a href="http://yoursite.com/2022/07/27/JavaDay7.html/" title="http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;07&#x2F;27&#x2F;JavaDay7.html&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;07&#x2F;27&#x2F;JavaDay7.html&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'MingWill-Marvel.github.io',
        owner: 'MingWill-Marvel',
        admin: 'MingWill-Marvel'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1660569633946"></script>
  






</body>

</html>
