<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Java基础Day9-Java高级类特性 - 火星环游日记</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础Day9-Java高级类特性">
<meta property="og:url" content="http://yoursite.com/2022/07/31/JavaDay9.html/index.html">
<meta property="og:site_name" content="火星环游日记">
<meta property="og:description" content="一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java12.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java515.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java516.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java517.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java518.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java519.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java520.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java521.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java522.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java523.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java524.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java525.PNG">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java526.PNG">
<meta property="article:published_time" content="2022-07-31T15:42:13.000Z">
<meta property="article:modified_time" content="2022-08-10T14:00:36.550Z">
<meta property="article:author" content="非酋囧菌">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1660572297316">
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="mdui-drawer-body-left">
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/logo/a1.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="非酋囧菌" class="mdui-btn mdui-btn-icon"><img src="/images/logo/a3.jpg" alt="非酋囧菌"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="非酋囧菌">
            <img src="/images/logo/a3.jpg" alt="非酋囧菌" alt="非酋囧菌">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>59</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/me.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/py.html" title="我的基友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的基友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1161831210" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/33638990" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 非酋囧菌
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
          <img data-src="/images/JavaStudyData/banner.jpg" data-sizes="auto" alt="Java基础Day9-Java高级类特性" class="lazyload">
          <h1>Java基础Day9-Java高级类特性</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年07月31日</a>
    <a><i class="nexmoefont icon-areachart"></i>4.3k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 19 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <p>一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。</p>
<a id="more"></a>
<h2 id="学习思维导图"><a href="#学习思维导图" class="headerlink" title="学习思维导图"></a>学习思维导图</h2><p><img data-sizes="auto" data-src="/images/JavaStudyData/java11.jpg" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java12.jpg" alt="" class="lazyload"></p>
<h3 id="5-3-类的成员之四：初始化块"><a href="#5-3-类的成员之四：初始化块" class="headerlink" title="5.3  类的成员之四：初始化块"></a>5.3  类的成员之四：初始化块</h3><p><img data-sizes="auto" data-src="/images/JavaStudyData/java515.PNG" alt="" class="lazyload"></p>
<ul>
<li><p>初始化块(代码块)作用：</p>
<ul>
<li>对Java对象进行初始化</li>
</ul>
</li>
<li><p>程序的执行顺序：</p>
</li>
</ul>
<p>声明成员变量的默认值</p>
<p>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</p>
<p>构造器再对成员进行赋值操作</p>
<pre><code>public class Person {
    String name;

    public Person() {
        this.name = &quot;张三&quot;;
        System.out.println(&quot;执行的是构造方法&quot;);
 }

    //非静态代码块
    {
        ystem.out.println(&quot;执行非静态代码块&quot;);
    }
}


public class Test {
    public static void main(String[] args) {
        new Person();

    }
}</code></pre><ul>
<li><p>在new Person()执行时：</p>
<ol>
<li>类的属性默认值初始化和显示初始化</li>
<li>执行构造器方法</li>
<li>执行代码块的代码（多个代码块按顺序执行）</li>
</ol>
</li>
</ul>
<h4 id="5-3-类的成员之四：初始化块-1"><a href="#5-3-类的成员之四：初始化块-1" class="headerlink" title="5.3  类的成员之四：初始化块"></a>5.3  类的成员之四：初始化块</h4><ul>
<li><p>一个类中初始化块若有修饰符，则只能被static修饰，称为静态代码块(static block )，当类被载入时，类属性的声明和静态代码块先后顺序被执行，且只被执行一次。</p>
</li>
<li><p><strong>static块通常用于初始化static (类)属性</strong></p>
<pre><code>class Person {
public static int total;
static {
      total = 100;//为total赋初值
   }
 …… //其它属性或方法声明
 }</code></pre></li>
</ul>
<h4 id="5-3-类的成员之四：初始化块-2"><a href="#5-3-类的成员之四：初始化块-2" class="headerlink" title="5.3  类的成员之四：初始化块"></a>5.3  类的成员之四：初始化块</h4><ul>
<li><p>非静态代码块：没有static修饰的代码块</p>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性声明进行初始化操作。</li>
<li>可以调用静态和非静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行</li>
</ol>
</li>
<li><p>静态代码块：用static 修饰的代码块</p>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块只执行一次</li>
</ol>
</li>
</ul>
<blockquote>
<p>在程序的运行过程中，非静态代码块每次new对象都要重新执行，静态代码块只执行一次。</p>
</blockquote>
<blockquote>
<p>在实际开发中，static静态代码块用在初始化类的静态属性（static类型属性）</p>
</blockquote>
<pre><code>//匿名内部类
Person p = new Person(){//这就是一个Person的匿名子类
  //问题？现在想把name改成李四，但是不想动Person的代码
  //在匿名内部类，可以用代码代替构造方法  
  {
    super.name = &quot;李四&quot;;
  }
  @Override
  public void Test(){
    System.out.println(&quot;=====&quot;)
  }
};</code></pre><ul>
<li><p>创建了一个没有类名的Person的子类，也就是匿名的Person的子类</p>
</li>
<li><p>这种类没有类名，就不能显式的new的方法创建对象，如果要是还有在构造器中初始化属性就没有办法了，这样情况就要用代码块{}初始化的构造</p>
<h4 id="初始化块举例"><a href="#初始化块举例" class="headerlink" title="初始化块举例"></a>初始化块举例</h4></li>
</ul>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java516.PNG" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java517.PNG" alt="" class="lazyload"></p>
<hr>
<h3 id="5-4-关键字：final"><a href="#5-4-关键字：final" class="headerlink" title="5.4  关键字：final"></a>5.4  关键字：final</h3><ul>
<li><p>在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。</p>
<ul>
<li><p>final标记的类不能被继承。提高安全性，提高程序的可读性。</p>
<p>如：String类、System类、StringBuffer类</p>
<pre><code>final class A{
}
class B extends A{//错误，不能被继承
}</code></pre><p>  <strong>Final修饰的类不能被继承</strong></p>
</li>
<li><p>final标记的方法不能被子类重写。</p>
<p>如：Object类中的getClass()。</p>
<pre><code>class A{
  public final void print(){
       System.out.println(“A”);
  }
 }
 class B extends A{     
   public void print(){   //错误，不能被重写。
         System.out.println(“众软”);
    }
  }</code></pre><p>  <strong>Final修饰的方法不能被子类重写</strong></p>
</li>
<li><p>final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。</p>
<pre><code>class  A{
   private final String INFO = “众软”;  //声明常量
   public void print(){
      //INFO = “众软”;
    }
 }</code></pre><p>  <strong>常量名要大写，内容不可修改。</strong></p>
</li>
<li><p>final标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。</p>
<pre><code>final double PI=3.14;//final修饰的变量就是常量，常量必须显式赋值。
final static String NAME_1 = &quot;&quot;;//final static一起修饰变量，就是全局常量
//常量定义名称约定使用大写，如果多个单词组成，用_连接
//常量只能赋值一次，不能再改变</code></pre><p>  <strong>static final：修饰全局常量</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="关键字final应用举例"><a href="#关键字final应用举例" class="headerlink" title="关键字final应用举例"></a>关键字final应用举例</h4><pre><code>public final class Test{
        public static int totalNumber = 5 ;
        public final int ID;
        public Test(){
              ID = ++totalNumber;  //可在构造方法中给final变量赋值
        }
         public static void main(String[] args) {
              Test t = new Test();
              System.out.println(t.ID);        
              final int I = 10;
              final int J;
              J = 20;
              J = 30;  //非法
     }
}</code></pre><blockquote>
<p>final代表最终，可以修饰变量，方法，类；</p>
</blockquote>
<blockquote>
<p>修饰变量，即为常量，只能赋值一次，不能改变；</p>
</blockquote>
<blockquote>
<p>修饰方法，子类不能重新修写；</p>
</blockquote>
<blockquote>
<p>修饰类，类不能被继承</p>
</blockquote>
<hr>
<h3 id="5-5-抽象类-abstract-class"><a href="#5-5-抽象类-abstract-class" class="headerlink" title="5.5  抽象类(abstract class)"></a>5.5  抽象类(abstract class)</h3><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java518.PNG" alt="" class="lazyload"></p>
<pre><code>/**
* @package: day09
* @className: Animal
* @author: MingWill
* @description: TODO
* @date: 2022/8/3 23:53
* @version: 1.0
*/
public abstract class Animal {
public abstract void test();//只要类中有一个抽象方法，类必须是一个抽象类

public abstract void move();
}

class Dog extends Animal{

@Override
public void test() {

}

@Override
public void move() {
    System.out.println(&quot;狗的移动方式是跑&quot;);

}
}

class Fish extends Animal{

@Override
public void test() {

}

@Override
public void move() {
    System.out.println(&quot;鱼的移动方式是游&quot;);

}
}

abstract class Bird extends Animal{ //抽象类可以继承抽象类

@Override
public void move() {

}

@Override
public abstract void test();

}</code></pre><ul>
<li><p>用abstract关键字来修饰一个类时，这个类叫做抽象类；</p>
</li>
<li><p>用abstract来修饰一个方法时，该方法叫做抽象方法。</p>
<ul>
<li>抽象方法：只有方法的声明，没有方法的实现。以分号结束：abstract int abstractMethod( int a );</li>
</ul>
</li>
<li><p>含有抽象方法的类必须被声明为抽象类。</p>
</li>
<li><p>抽象类不能被实例化。抽象类是用来作为父类被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</li>
<li><p>不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法</p>
</li>
</ul>
<blockquote>
<p>只要类中存在一个抽象方法，那么这个类就必须是一个抽象类。</p>
</blockquote>
<h4 id="抽象类举例"><a href="#抽象类举例" class="headerlink" title="抽象类举例"></a>抽象类举例</h4><pre><code>abstract class A{   
  abstract void m1( );

  public void m2( ){
        System.out.println(&quot;A类中定义的m2方法&quot;);
  }
}

  class B extends A{
     void m1( ){
           System.out.println(&quot;B类中定义的m1方法&quot;);
     }
  }

  public class Test{
     public static void main( String args[ ] ){
           A a = new B( );
           a.m1( );
           a.m2( );
     }
  }</code></pre><h4 id="抽象类应用"><a href="#抽象类应用" class="headerlink" title="抽象类应用"></a>抽象类应用</h4><p>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java519.PNG" alt="" class="lazyload"></p>
<ul>
<li>在航运公司系统中，Vehicle类需要定义两个方法分别计算运输工具的燃料效率和行驶距离</li>
<li>问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</li>
</ul>
<h4 id="抽象类应用-1"><a href="#抽象类应用-1" class="headerlink" title="抽象类应用"></a>抽象类应用</h4><ul>
<li><p>解决方案<br>  Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p>
</li>
<li><p>Vehicle是一个抽象类，有两个抽象方法。</p>
<pre><code>public abstract class Vehicle{
public abstract double   calcFuelEfficiency();        //计算燃料效率的抽象方法
public abstract double  calcTripDistance();     //计算行驶距离的抽象方法
 }
 public class Truck extends Vehicle{
  public double calcFuelEfficiency( )   { //写出计算卡车的燃料效率的具体方法   }
    public double calcTripDistance( )    {  //写出计算卡车行驶距离的具体方法   }
}

  public class RiverBarge extends Vehicle{
  public double calcFuelEfficiency( ) { //写出计算驳船的燃料效率的具体方法  }
   public double calcTripDistance( )  {  //写出计算驳船行驶距离的具体方法}
   }</code></pre></li>
<li><p><strong>注意：抽象类不能实例化   new Vihicle()是非法的</strong></p>
</li>
</ul>
<p>问题1：为什么抽象类不可以使用final关键字声明？</p>
<p>  （抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体）</p>
<blockquote>
<p>final是最终，他修饰的类是最终类，不能被继承。</p>
</blockquote>
<blockquote>
<p>抽象类。如果想要使用，必须继承抽象类，实现那些抽象方法。</p>
</blockquote>
<p>问题2：一个抽象类中可以定义构造器吗？</p>
<p>抽象类可以有构造方法，只是不能直接创建抽象类的实例对象而已。<br>抽象类不能实例化   new Vihicle()是非法的</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p>
<pre><code>/**
 * @package: day09
 * @className: Employee
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/4 0:10
 * @version: 1.0
 */
public abstract class Employee {

    public Employee(){

    }
    int id;
    String name;
    double salary;

    public abstract void work();
}

class CommonEmployee extends Employee{

    public void setCommonEmployeeInfo(int id,String name,double salary){
       super.id = id;
       super.name = name;
       super.salary = salary;
    }

    public void getCommonEmployeeInfo(){
        System.out.println( super.id );
        System.out.println(super.name);
        System.out.println(super.salary);
    }
    @Override
    public void work() {
        System.out.println(&quot;这是一个普通员工&quot;);
    }
}


class  Manager extends Employee{

    double bonus;

    public void setBonusInfo(int id,String name,double salary,double bonus){
        super.id = id;
        super.name = name;
        super.salary = salary;
        this.bonus = bonus;
    }

    public void getBonusInfo(){
        System.out.println( super.id );
        System.out.println(super.name);
        System.out.println(super.salary);
        System.out.println(this.bonus);
    }

    @Override
    public void work() {

        System.out.println(&quot;这是领导&quot;);

    }
}


/**
 * @package: day09
 * @className: Test
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/2 23:56
 * @version: 1.0
 */
public class Test {
    public static void main(String[] args) {

        CommonEmployee ce = new CommonEmployee();
        ce.setCommonEmployeeInfo(6628,&quot;张三&quot;,6812.5);
        ce.work();
        ce.getCommonEmployeeInfo();

        Manager mg = new Manager();
        mg.setBonusInfo(8888,&quot;光头强&quot;,9816.5,2300.67);
        mg.work();
        mg.getBonusInfo();
    }
}</code></pre><hr>
<h3 id="模板方法设计模式-TemplateMethod"><a href="#模板方法设计模式-TemplateMethod" class="headerlink" title="模板方法设计模式(TemplateMethod)"></a>模板方法设计模式(TemplateMethod)</h3><ul>
<li><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
</li>
<li><p><strong>解决的问题：</strong></p>
<ul>
<li>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。</li>
</ul>
</li>
</ul>
<pre><code>abstract class Template{
      public final void getTime(){
            long start = System.currentTimeMillis();
            code();
            long end = System.currentTimeMillis();
            System.out.println(&quot;执行时间是：&quot;+(end - start));
      }
      public abstract void code();
}

class SubTemplate extends Template{
      public void code(){
            for(int i = 0;i&lt;10000;i++){
                System.out.println(i);
        }
    }
}</code></pre><p>例子：</p>
<pre><code>package day09;

/**
 * @package: day09
 * @className: Template
 * @author: MingWill
 * @description: 模板设计模式
 * @date: 2022/8/4 0:34
 * @version: 1.0
 */
public abstract class Template {

    public abstract void code();

    public final void getTime(){
        long start = System.currentTimeMillis();
        code();
        long end = System.currentTimeMillis();

        System.out.println(&quot;code方法执行的时间:&quot; + (end - start));
    }
}
class TestTmp extends Template{

    @Override
    public void code() {
        int k = 0;
        for (int i = 0; i &lt; 5000;i++){
            k += 1;
        }
        System.out.println(k);
    }
}


public class Test {
public static void main(String[] args) {

    TestTmp t = new TestTmp();
    t.getTime();
  }
}</code></pre><hr>
<h3 id="5-6-接-口"><a href="#5-6-接-口" class="headerlink" title="5.6 接 口"></a>5.6 接 口</h3><ul>
<li><p>有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
</li>
<li><p>接口(interface)是抽象方法和常量值的定义的集合。</p>
</li>
<li><p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
</li>
<li><p>实现接口类：<br>class SubClass implements InterfaceA{ }</p>
</li>
<li><p>一个类可以实现多个接口，接口也可以继承其它接口。</p>
</li>
<li><p>接口的特点：</p>
<ul>
<li>用interface来定义。</li>
<li>接口中的所有成员变量都默认是由public static final修饰的。</li>
<li>接口中的所有方法都默认是由public abstract修饰的。</li>
<li>接口没有构造器。</li>
<li>接口采用多层继承机制。</li>
</ul>
</li>
</ul>
<p>*接口定义举例</p>
<pre><code>public interface Runner {
    int ID = 1;
    void start();
     public void run();
    void stop();
}</code></pre><ul>
<li><p>实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。</p>
</li>
<li><p>接口的主要用途就是被实现类实现。（面向接口编程）</p>
</li>
<li><p>与继承关系类似，接口与实现类之间存在多态性</p>
</li>
<li><p>定义Java类的语法格式：先写extends，后写implements</p>
<pre><code>  &lt; modifier&gt; class &lt; name&gt; [extends &lt; superclass&gt;]
[implements &lt; interface&gt; [,&lt; interface&gt;]* ] {
 &lt; declarations&gt;*
}</code></pre></li>
</ul>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java520.PNG" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java521.PNG" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java522.PNG" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java523.PNG" alt="" class="lazyload"></p>
<h4 id="接口应用举例-1"><a href="#接口应用举例-1" class="headerlink" title="接口应用举例(1)"></a>接口应用举例(1)</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java524.PNG" alt="" class="lazyload"></p>
<h4 id="接口应用举例-2"><a href="#接口应用举例-2" class="headerlink" title="接口应用举例(2)"></a>接口应用举例(2)</h4><ul>
<li>一个类可以实现多个无关的接口</li>
</ul>
<pre><code>interface Runner {
  public void run();
}
interface Swimmer {
  public double swim();
}
class Creator{
  public int eat(){…}
}
class Man extends Creator implements Runner ,Swimmer{
    public void run() {……}
    public double swim()  {……}
    public int eat() {……}
}</code></pre><ul>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
</ul>
<pre><code>public class Test{
       public static void main(String args[]){
            Test t = new Test();
            Man m = new Man();
            t.m1(m);
            t.m2(m);
            t.m3(m);
    }
       public String m1(Runner f) { f.run(); }
       public void  m2(Swimmer s) {s.swim();}
       public void  m3(Creator a) {a.eat();}
}</code></pre><h4 id="接口的其他问题"><a href="#接口的其他问题" class="headerlink" title="接口的其他问题"></a>接口的其他问题</h4><ul>
<li>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类</li>
<li>接口也可以继承另一个接口，使用extends关键字。</li>
</ul>
<pre><code>interface MyInterface{
        String s=“MyInterface”;
        public void absM1();
  }
  interface SubInterface extends MyInterface{
        public void absM2();
  }
  public class SubAdapter implements SubInterface{
        public void absM1(){
        System.out.println(“absM1”);
    }
        public void absM2(){
        System.out.println(“absM2”);
    }
}</code></pre><ul>
<li>实现类SubAdapter必须给出接口SubInterface以及父接口MyInterface中所有方法的实现。</li>
</ul>
<hr>
<h4 id="工厂方法-FactoryMethod"><a href="#工厂方法-FactoryMethod" class="headerlink" title="工厂方法(FactoryMethod)"></a>工厂方法(FactoryMethod)</h4><ul>
<li><strong>FactoryMethod模式是设计模式中应用最为广泛的模式，在面向对象的编程中，对象的创建工作非常简单，对象的创建时机却很重要。FactoryMethod解决的就是这个问题，它通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。</strong></li>
</ul>
<h4 id="工厂方法举例"><a href="#工厂方法举例" class="headerlink" title="工厂方法举例"></a>工厂方法举例</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java525.PNG" alt="" class="lazyload"></p>
<hr>
<h3 id="5-7-类的成员之五：内部类"><a href="#5-7-类的成员之五：内部类" class="headerlink" title="5.7  类的成员之五：内部类"></a>5.7  类的成员之五：内部类</h3><ul>
<li><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p>
</li>
<li><p>Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。</p>
<ul>
<li>Inner class的名字不能与包含它的类名相同；</li>
</ul>
</li>
<li><p>Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。</p>
</li>
<li><p>分类：</p>
<ul>
<li>成员内部类（static成员内部类和非static成员内部类）</li>
<li>局部内部类（不谈修饰符）、匿名内部类</li>
</ul>
</li>
</ul>
<h4 id="内部类举例-1"><a href="#内部类举例-1" class="headerlink" title="内部类举例 (1)"></a>内部类举例 (1)</h4><pre><code>class A {
     private int s;
     public class B{
         public void mb() {
               s = 100;     
               System.out.println(&quot;在内部类B中s=&quot; + s);
         }  
   }
     public void ma() {
            B i = new B();
            i.mb();
     }
}


public class Test {
       public static void main(String args[]){
            A o = new A();
            o.ma();
      }
}</code></pre><h4 id="内部类特性"><a href="#内部类特性" class="headerlink" title="内部类特性"></a>内部类特性</h4><ul>
<li>Inner class作为类的成员：<ul>
<li>可以声明为final的</li>
<li>和外部类不同，Inner class可声明为private或protected；</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li>Inner class作为类：<ul>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
</ul>
</li>
</ul>
<p><strong>【注意】非static的内部类中的成员不能声明为static的，只有在外部类或static的内部类中才可声明static成员。</strong></p>
<blockquote>
<p>内部类主要解决Java不能多重继承问题。</p>
</blockquote>
<pre><code>/**
 * @package: day09
 * @className: Test4
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/6 23:33
 * @version: 1.0
 */
public class Test4 {

    public static void main(String[] args) {
        A a = new A();
        a.TestB();
        a.TestC();
    }
}
/**
 * 现在类A想同时获得类B和类C的方法，并且重写
 * 可以使用内部类来变相的实现类的多重继承，可以同时继承多个类
 */
class A{
    public void TestB(){
        new InnerB().testB();
    }

    public void TestC(){
        new InnerC().testC();
    }

    private class InnerB extends B{
        @Override
        public void testB() {
            System.out.println(&quot;这是重写之后的TestB方法&quot;);
        }
    }
    private class InnerC extends C{
        @Override
        public void testC() {
            System.out.println(&quot;这是重写之后的TestC方法&quot;);
        }
    }
}
class  B{
    public void testB(){
    }
}
class C{
    public void testC(){
    }

}</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</p>
<pre><code>new 父类构造器（实参列表）|实现接口(){
 //匿名内部类的类体部分
}</code></pre></li>
</ul>
<pre><code>interface  A{
public  abstract void fun1();
  }
public class Outer{
 public static void main(String[] args) {
 new Outer().callInner(new A(){
        //接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名
     public void fun1() {
         System.out.println(“implement for fun1&quot;);
     }
    });// 两步写成一步了
    }
  public void callInner(A a) {
 a.fun1();
    }
  }  </code></pre><hr>
<h3 id="面向对象内容总结"><a href="#面向对象内容总结" class="headerlink" title="面向对象内容总结"></a>面向对象内容总结</h3><p><img data-sizes="auto" data-src="/images/JavaStudyData/java526.PNG" alt="" class="lazyload"></p>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>非酋囧菌<br>
    <strong>本文链接：</strong><a href="http://yoursite.com/2022/07/31/JavaDay9.html/" title="http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;07&#x2F;31&#x2F;JavaDay9.html&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;07&#x2F;31&#x2F;JavaDay9.html&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'MingWill-Marvel.github.io',
        owner: 'MingWill-Marvel',
        admin: 'MingWill-Marvel'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1660572297318"></script>
  






</body>

</html>
