<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Java基础Day10-异常和集合 - 火星环游日记</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如除数为0，数组下标越界，要读写的文件不存在等等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础Day10-异常和集合">
<meta property="og:url" content="http://yoursite.com/2022/08/06/JavaDay10.html/index.html">
<meta property="og:site_name" content="火星环游日记">
<meta property="og:description" content="任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如除数为0，数组下标越界，要读写的文件不存在等等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java12.jpg">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java101.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java102.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java103.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java104.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java105.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java106.png">
<meta property="og:image" content="http://yoursite.com/images/JavaStudyData/java107.png">
<meta property="article:published_time" content="2022-08-06T14:42:13.000Z">
<meta property="article:modified_time" content="2022-08-09T14:47:48.939Z">
<meta property="article:author" content="非酋囧菌">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/JavaStudyData/java11.jpg">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1660572297313">
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="mdui-drawer-body-left">
  <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/logo/a1.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="非酋囧菌" class="mdui-btn mdui-btn-icon"><img src="/images/logo/a3.jpg" alt="非酋囧菌"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="非酋囧菌">
            <img src="/images/logo/a3.jpg" alt="非酋囧菌" alt="非酋囧菌">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>59</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/me.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/py.html" title="我的基友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的基友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1161831210" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/33638990" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">42</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 非酋囧菌
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
          <img data-src="/images/JavaStudyData/banner.jpg" data-sizes="auto" alt="Java基础Day10-异常和集合" class="lazyload">
          <h1>Java基础Day10-异常和集合</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年08月06日</a>
    <a><i class="nexmoefont icon-areachart"></i>6.5k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 30 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <p>任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如除数为0，数组下标越界，要读写的文件不存在等等。</p>
<a id="more"></a>
<h2 id="学习思维导图"><a href="#学习思维导图" class="headerlink" title="学习思维导图"></a>学习思维导图</h2><p><img data-sizes="auto" data-src="/images/JavaStudyData/java11.jpg" alt="" class="lazyload"><br><img data-sizes="auto" data-src="/images/JavaStudyData/java12.jpg" alt="" class="lazyload"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h4><ul>
<li><p>任何一种程序设计语言设计的程序在运行时都有可能出现错误，例如除数为0，数组下标越界，要读写的文件不存在等等。</p>
</li>
<li><p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。</p>
</li>
<li><p>对于这些错误，一般有两种解决方法：</p>
<ul>
<li>到错误就终止程序的运行。</li>
<li>由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</li>
</ul>
</li>
<li><p><strong>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。</strong></p>
</li>
<li><p><strong>Java中的异常用于处理非预期的情况，如文件没找到，网络错误，非法的参数</strong></p>
</li>
</ul>
<p>Java程序运行过程中所发生的异常事件可分为两类：</p>
<ul>
<li><p>Error:  JVM系统内部错误、资源耗尽等严重情况</p>
</li>
<li><p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
</ul>
</li>
</ul>
<p>Java异常举例（数组越界异常）：</p>
<pre><code>public class Test01{
      public static void main(String[] args) {
        String friends[]={&quot;lisa&quot;,&quot;bily&quot;,&quot;kessy&quot;};
        for(int i=0;i&lt;5;i++){
         System.out.println(friends[i]); //friends[4]?
      }
          System.out.println(&quot;\nthis is the end&quot;);
    }
 }

程序Test01编译正确，运行结果：java Test8_1
lisa
bily
kessy
java.lang.ArrayIndexOutOfBoundsException at Test01.main(Test01.java:5)
Exception in thread &quot;main&quot;</code></pre><p>例子：</p>
<pre><code>public class Test01 {
  public static void main(String[] args) {
    String strs[] = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;};
      for (int i=0;i&lt;4;i++){//0,1,2,3 strs没有第4个元素，这个时候要输出第strs[3]就没有

      //java.lang.ArrayIndexOutOfBoundsException 数组越界异常
      System.out.println(strs[i]);
      }
  }
}</code></pre><p>Java异常举例（空指针异常）：</p>
<pre><code>public class NullRef{
      int i=1;
    public static void main(String[] args) {
        NullRef t=new NullRef();
        t=null;          
        System.out.println(t.i);
  }
}

程序NullRef.java编译正确，运行结果：java NullRef
java.lang.NullPointerException
    at NullRef.main(NullRef.java:6)
Exception in thread &quot;main&quot;</code></pre><p>例子：</p>
<pre><code>public class Test01 {
    public static void main(String[] args) {
//        A a = new A();
        A a = null; //在这块，引用变量a没有指向任何对象，指向的是null，什么都没有，自然没有i的值

        //java.lang.NullPointerException 就会报空指针异常
        System.out.println(a.i);
    }
}
class A{
    int i;
}</code></pre><p>Java异常举例（算术异常）：</p>
<pre><code>public class DivideZero{
    int x;
    public static void main(String[] args) {
        int y;
        DivideZero c=new DivideZero();
        y=3/c.x;          
        System.out.println(“program ends ok!”);
  }
}

程序DivideZero.java编译正确，运行结果：java DivideZero
java.lang.ArithmeticException: / by zero
    at DivideZero.main(DivideZero.java:6)
Exception in thread &quot;main&quot;</code></pre><p>例子：</p>
<pre><code>public class Test01 {
    public static void main(String[] args) {
        int i = 0; //除以零，任何数不能除以零
        //java.lang.ArithmeticException 算术异常
        System.out.println(3/i);
    }
}</code></pre><blockquote>
<p>三种皆为运行时异常</p>
</blockquote>
<h4 id="Java异常类层次"><a href="#Java异常类层次" class="headerlink" title="Java异常类层次"></a>Java异常类层次</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java101.png" alt="" class="lazyload"></p>
<p>常见异常</p>
<ul>
<li>RuntimeException<ul>
<li>错误的类型转换</li>
<li>数组下标越界</li>
<li>空指针访问</li>
</ul>
</li>
<li>IOExeption<ul>
<li>从一个不存在的文件中读取数据</li>
<li>越过文件结尾继续读取EOFException</li>
<li>连接一个不存在的URL</li>
</ul>
</li>
</ul>
<h4 id="运行处理机制"><a href="#运行处理机制" class="headerlink" title="运行处理机制"></a>运行处理机制</h4><ul>
<li><p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的分支会导致程序的代码加长，可读性差。因此采用异常机制。</p>
</li>
<li><p>Java异常处理：<strong>Java采用异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护。</strong></p>
</li>
</ul>
<blockquote>
<p>Java提供的是异常处理的抓抛(捕获抛出)模型。</p>
</blockquote>
<blockquote>
<p>Java程序的执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</p>
</blockquote>
<blockquote>
<p>如果一个方法内抛出异常，该异常会被抛到调用方法中。如果异常没有在调用方法中处理，它继续被抛给这个调用方法的调用者。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。</p>
</blockquote>
<blockquote>
<p>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。<br>程序员通常只能处理Exception，而对Error无能为力。</p>
</blockquote>
<p>例子：</p>
<pre><code>public class Test01 {
    public static void main(String[] args) {

        int i = 0;
        try {//用try{}来括住一段可能出现异常的代码段
            System.out.println(3 / i);
           //由于异常，使中断，可以通过异常处理机制，防止程序中断
        }catch (Exception e){//当不知道捕获的是什么类型的异常时，可以直接使用所有异常的父类Exception
//            e.printStackTrace();
            System.out.println(e.getMessage());
        }
        System.out.println(&quot;ok&quot;);
    }
}</code></pre><p>异常处理举例(1)</p>
<pre><code>public class Test01{
    public static void main(String[] args){
        String friends[] = {&quot;lisa&quot;,&quot;bily&quot;,&quot;kessy&quot;};
          try{
            for(int i=0;i&lt;5;i++) {
               System.out.println(friends[i]);
           }
          }catch(ArrayIndexOutOfBoundsException e){
           System.out.println(&quot;index err&quot;);
          }
          System.out.println(&quot;\nthis is the end&quot;);
  }
}
程序Test01运行结果：lisa    bily    kessy  
index err this is the end   </code></pre><p>异常处理举例(2)</p>
<pre><code>public class DivideZero1{
    int x;
   public static void main(String[] args) {
         int y;
        DivideZero1 c=new DivideZero1();
        try{
            y=3/c.x;
        }
        catch(ArithmeticException e){          
            System.out.println(&quot;divide by zero error!&quot;);
        }
         System.out.println(&quot;program ends ok!&quot;);
  }
}
程序DivideZero1运行结果：
divide by zero error!
program ends ok!</code></pre><p>异常处理机制（3）</p>
<p>异常处理是通过try-catch-finally语句实现的。</p>
<pre><code>try
{
    ......    //可能产生异常的代码
}
catch( ExceptionName1 e )
{
    ......    //当产生ExceptionName1型异常时的处置措施
}
catch( ExceptionName2 e )
{
......     //当产生ExceptionName2型异常时的处置措施
}  
[ finally{
......     //无条件执行的语句(可写可不写，它是捕获异常的体系中最终一定会执行的部分，为了执行io操作和jdbc会接触)
  }  ]</code></pre><p>例子：</p>
<pre><code>public class Test01 {
    public static void main(String[] args) {


        String[] strs = new String[]{&quot;a&quot;,&quot;b&quot;};
        A a = null;

        //try catch 是防止程序可能出现的异常
        //在捕获异常的代码块中(try()里的代码)，如果前面的代码有异常了，就不会执行后面的
        try{
            System.out.println(strs[3]);
            System.out.println(a.i);
        }catch (ArrayIndexOutOfBoundsException e1){
            System.out.println(e1.getMessage());
            e1.printStackTrace();
        }catch (NullPointerException e2){
            System.out.println(e2.getMessage());
            e2.printStackTrace();
        }
    }
}
class A{
    int i;
}</code></pre><hr>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常(1)"></a>捕获异常(1)</h4><ul>
<li><p>try</p>
<p>  捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
</li>
<li><p>catch (Exceptiontype e)</p>
<p>  在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p><strong>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。</strong></p>
<p>  可以用ArithmeticException类作为参数，也可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException，那么，catch中的语句将不会执行。</p>
</li>
</ul>
<h4 id="捕获异常-2"><a href="#捕获异常-2" class="headerlink" title="捕获异常(2)"></a>捕获异常(2)</h4><ul>
<li><p>捕获异常的有关信息：</p>
<p>  与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p>
<ul>
<li>getMessage( ) 方法，用来得到有关异常事件的信息</li>
<li>printStackTrace( )用来跟踪异常事件发生时执行堆栈的内容。</li>
</ul>
</li>
</ul>
<h4 id="捕获异常-3"><a href="#捕获异常-3" class="headerlink" title="捕获异常(3)"></a>捕获异常(3)</h4><ul>
<li><p>finally</p>
<ul>
<li><p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。不论在try、catch代码块中是否发生了异常事件*</p>
</li>
<li><p>finally块中的语句都会被执行。<br>finally语句是可选的</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="声明抛出异常"><a href="#声明抛出异常" class="headerlink" title="声明抛出异常"></a>声明抛出异常</h3><p>声明抛出异常是Java中处理异常的第二种方式</p>
<p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<p>在方法声明中用 throws 子句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
<p>声明抛出异常举例：</p>
<pre><code>public void readFile(String file)  throws FileNotFoundException {
    ……
    // 读文件的操作可能产生FileNotFoundException类型的异常
    FileInputStream fis = new FileInputStream(file);
     ..……
 }</code></pre><p>例子：</p>
<pre><code>public class Test1 {
    public static void main(String[] args) throws Exception { //可以在main方法继续抛出异常
        //main方法抛出异常直接抛到虚拟机上去了，就在程序中不能处理
        S s = new S();
        try {//throws在代码这抛出异常，在调用方法捕获处理
            s.test();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

}
class S{
    int i;
    public void test() throws Exception{//可以使用throws在代码这抛出异常，在调用方法捕获处理
        S s = null;
        System.out.println(s.i);
    }
}</code></pre><p>声明抛出异常示例</p>
<pre><code>import java.io.*;
public class Test01{
    public static void main(String[] args){
        Test8_5 t = new Test8_5();
        try{
             t.readFile();
         }catch(IOException e){   }
    }
    public void readFile()throws IOException {
        FileInputStream in=new FileInputStream(&quot;myfile.txt&quot;);
        int b;
        b = in.read();
        while(b!= -1)   {
            System.out.print((char)b);
            b = in.read();
        }
        in.close();
    }
}</code></pre><h4 id="重写方法声明抛出异常的原则"><a href="#重写方法声明抛出异常的原则" class="headerlink" title="重写方法声明抛出异常的原则"></a>重写方法声明抛出异常的原则</h4><blockquote>
<p>重写方法不能抛出比被重写方法范围更大的异常类型</p>
</blockquote>
<pre><code>public class A {
     public void methodA() throws IOException {
          ……
     }
}
public class B1 extends A {
     public void methodA() throws FileNotFoundException {
         ……
     }
}
public class B2 extends A {
     public void methodA() throws Exception {   //error 重写方法不能抛出比被重写方法范围更大的异常类型
            ……
  }
}</code></pre><h4 id="人工抛出异常"><a href="#人工抛出异常" class="headerlink" title="人工抛出异常"></a>人工抛出异常</h4><ul>
<li><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要人工创建并抛出</p>
<ul>
<li><p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。</p>
<pre><code>IOException e =new IOException();
throw e;</code></pre></li>
<li><p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</p>
<pre><code>throw new String(&quot;want to throw&quot;);</code></pre></li>
</ul>
</li>
</ul>
<h4 id="创建用户自定义异常类"><a href="#创建用户自定义异常类" class="headerlink" title="创建用户自定义异常类"></a>创建用户自定义异常类</h4><blockquote>
<p>用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。</p>
</blockquote>
<pre><code>class MyException extends Exception {
       private int idnumber;
     public MyException(String message, int id) {
        super(message);
        this.idnumber = id;
     }
    public int getId() {
        return idnumber;
     }
}</code></pre><h4 id="使用用户自定义异常类"><a href="#使用用户自定义异常类" class="headerlink" title="使用用户自定义异常类"></a>使用用户自定义异常类</h4><pre><code>public class Test01{
        public void regist(int num) throws MyException {
     if (num &lt; 0)
               throw new MyException(“人数为负值，不合理”,3);
    else
              System.out.println(&quot;登记人数&quot; + num );
        }
        public void manager() {
     try {
               regist(100);
     } catch (MyException e) {
                System.out.print(&quot;登记失败，出错种类&quot;+e.getId());         
    }
    System.out.print(&quot;本次登记操作结束&quot;);
       }
       public static void main(String args[]){
    Test8_6 t = new Test8_6();
    t.manager();
       }
}</code></pre><blockquote>
<p>java提供的异常的类一般是够用的，只有一些特殊情况可能需要自己编写异常类，这种情况很少见。</p>
</blockquote>
<hr>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="Java-集合概述"><a href="#Java-集合概述" class="headerlink" title="Java 集合概述"></a>Java 集合概述</h4><ul>
<li>Java集合类存放于 java.util 包中，是一个用来存放对象的容器。<ul>
<li>①、集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型。</li>
<li>②、集合存放的是多个对象的引用，对象本身还是放在堆内存中。</li>
<li>③、集合可以存放不同类型，不限数量的数据类型。</li>
</ul>
</li>
<li>Java 集合可分为 Set、List 和 Map 三种大体系<ul>
<li>Set：无序、不可重复的集合</li>
<li>List：有序，可重复的集合</li>
<li>Map：具有映射关系的集合</li>
</ul>
</li>
</ul>
<p>在 JDK5 之后，增加了泛型，Java 集合可以记住容器中对象的数据类型</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><strong>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。我们大多数时候说的set集合指的都是HashSet</strong></p>
<p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。<br>HashSet 具有以下特点：</p>
<ul>
<li><strong>不能保证元素的排列顺序</strong></li>
<li><strong>不可重复</strong>(指hashcode不同)</li>
<li><strong>HashSet 不是线程安全的</strong></li>
<li><strong>集合元素可以使 null</strong></li>
</ul>
<p>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。</p>
<p>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java102.png" alt="" class="lazyload"></p>
<p>例子：</p>
<pre><code>package day10;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * @package: day10
 * @className: Test3
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/9 0:15
 * @version: 1.0
 */
public class Test3 {
    public static void main(String[] args) {
        Set set = new HashSet();
        set.add(1);//添加元素
        set.add(&quot;e&quot;);

        System.out.println(set);

        set.remove(1);//移除元素

        System.out.println(set);

        System.out.println(set.contains(&quot;e&quot;));//判断是否包含元素

        set.clear();//清空元素
        System.out.println(set);


        set.add(&quot;a&quot;);
        set.add(&quot;b&quot;);
        set.add(&quot;c&quot;);
        set.add(&quot;d&quot;);

        set.add(&quot;d&quot;);//set集合存的值是不重复的

        set.add(null);//

        System.out.println(set);
      //使用迭代器遍历集合
        Iterator it = set.iterator();

        while (it.hasNext()){
            System.out.println(it.next());
        }

        //for each迭代集合
        for (Object obj :set){//这个意思是说把set的每一个值取出来，赋值给obj，直到循环set的所有值
            System.out.println(obj);
        }

        System.out.println(set.size());//获取集合的元素个数
    }
}</code></pre><h4 id="使用-Iterator-接口遍历集合元素"><a href="#使用-Iterator-接口遍历集合元素" class="headerlink" title="使用 Iterator 接口遍历集合元素"></a>使用 Iterator 接口遍历集合元素</h4><p>Iterator 接口主要用于遍历 Collection 集合中的元素，Iterator 对象也被称为迭代器</p>
<p>Iterator 接口隐藏了各种 Collection 实现类的底层细节，向应用程序提供了遍历 Collection 集合元素的统一编程接口</p>
<p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java103.png" alt="" class="lazyload"></p>
<h4 id="使用-foreach-循环遍历集合元素-推荐使用"><a href="#使用-foreach-循环遍历集合元素-推荐使用" class="headerlink" title="使用 foreach 循环遍历集合元素(推荐使用)"></a>使用 foreach 循环遍历集合元素(推荐使用)</h4><p>Java 5 提供了 foreach 循环迭代访问 Collection</p>
<pre><code>for(Person preson : set){
  System.out.println(set.getName);
}</code></pre><h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><p>HashSet 集合判断两个元素相等的标准：两个对象通过 equals() 方法比较相等，并且两个对象的 hashCode() 方法返回值也相等。</p>
<p><strong>如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。</strong></p>
<h4 id="集合中的泛型"><a href="#集合中的泛型" class="headerlink" title="集合中的泛型"></a>集合中的泛型</h4><pre><code>//如果想要让集合只能存同种类型的对象，怎么做
//使用泛型

Set&lt;String&gt; set1 = new HashSet&lt;String&gt;();//比如指定String为集合的泛型，那么这个集合就不能存String类型之外的数据

set1.add(&quot;abc&quot;);
//set1.add(1);//指定泛型,不能存int类型

}
}</code></pre><blockquote>
<p>指定泛型可以使集合不能存储泛型以外的数据。</p>
</blockquote>
<blockquote>
<p>当泛型为Object时，所有对象都能存储。</p>
</blockquote>
<hr>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</p>
<p><strong>TreeSet 支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</strong></p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java104.png" alt="" class="lazyload"></p>
<p>例子：</p>
<pre><code>package day10;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

/**
 * @package: day10
 * @className: Test4
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/9 0:48
 * @version: 1.0
 */
public class Test4 {
    public static void main(String[] args) {
        Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        //TreeSet自然排序
        set.add(5);
        set.add(2);
        set.add(4);
        set.add(3);
        System.out.println(set);
        set.remove(4);
//        set.clear();
        System.out.println(set.contains(5));

        //使用迭代器遍历集合

        Iterator&lt;Integer&gt; it = set.iterator();
        while (it.hasNext()){
        System.out.println(it.next());
        }

        //for each 迭代集合，推荐使用这种

        for (Integer i : set){
            System.out.println(i);
        }

    }
}</code></pre><h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p>排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列</p>
<ul>
<li>如果 this &gt; obj,返回正数 1</li>
<li>如果 this &lt; obj,返回负数 -1</li>
<li>如果 this = obj,返回 0 ，则认为这两个对象相等</li>
</ul>
<p><strong>必须放入同样类的对象.(默认会进行排序) 否则可能会发生类型转换异常.我们可以使用泛型来进行限制</strong></p>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p><strong>如果需要实现定制排序，则需要在创建 TreeSet 集合对象时，提供一个 Comparator 接口的实现类对象。由该 Comparator 对象负责集合元素的排序逻辑</strong></p>
<p>例子：</p>
<pre><code>package day10;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

/**
 * @package: day10
 * @className: Test4
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/9 0:48
 * @version: 1.0
 */
public class Test4 {
    public static void main(String[] args) {

        Person p1 = new Person(&quot;张三&quot;,23);
        Person p2 = new Person(&quot;李四&quot;,12);
        Person p3 = new Person(&quot;王五&quot;,34);
        Person p4 = new Person(&quot;老六&quot;,31);

        Set&lt;Person&gt; set = new TreeSet&lt;&gt;(new Person());

        set.add(p1);
        set.add(p2);
        set.add(p3);
        set.add(p4);

        for (Person p :set){
            System.out.println(p.name +&quot;   &quot;+p.age);
        }

    }
}

class Person implements Comparator&lt;Person&gt; {//把person对象存到treeSet中并按照年龄排序
    int age;
    String name;
    public Person(){

    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public int compare(Person o1, Person o2) {//年龄正序排列
        if (o1.age&gt;o2.age){
            return 1;
        }else if (o1.age&lt;o2.age){
            return -1;
        }else {
            return 0;
        }
    }
}</code></pre><hr>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="List与ArrayList"><a href="#List与ArrayList" class="headerlink" title="List与ArrayList"></a>List与ArrayList</h4><p>List 代表一个元素有序、且可重复的集合，集合中的每个元素都有其对应的顺序索引</p>
<p>List 允许使用重复元素，可以通过索引来访问指定位置的集合元素。</p>
<p>List 默认按元素的添加顺序设置元素的索引。</p>
<p>List 集合里添加了一些根据索引来操作集合元素的方法</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java105.png" alt="" class="lazyload"></p>
<p>例子：</p>
<pre><code>package day10;

import java.util.ArrayList;
import java.util.List;

/**
* @package: day10
* @className: Test5
* @author: MingWill
* @description: TODO
* @date: 2022/8/9 20:32
* @version: 1.0
*/
public class Test5 {
public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;b&quot;);//第一个，索引下标0
    list.add(&quot;a&quot;);//索引下标1
    list.add(&quot;c&quot;);//索引下标2
    list.add(&quot;d&quot;);//索引下标3
    list.add(&quot;a&quot;);

    System.out.println(list);
    System.out.println(list.get(2));//通过索引来访问指定位置元素

    list.add(1,&quot;f&quot;);//在指定索引下标位置插入数据
    System.out.println(list);

    List&lt;String&gt; l = new ArrayList&lt;&gt;();
    l.add(&quot;123&quot;);
    l.add(&quot;456&quot;);

    list.addAll(2,l);//在指定索引下标位置插入集合

    System.out.println(list);

    System.out.println(list.indexOf(&quot;d&quot;));//获取指定元素在集合中第一次出现的索引下标
    System.out.println(list.lastIndexOf(&quot;d&quot;));////获取指定元素在集合中最后一次出现的索引下标

    list.remove(2);//根据指定下标移除元素
    System.out.println(list);

    list.set(1,&quot;ff&quot;);//根据指定索引下标修改元素
    System.out.println(list);
    //根据索引下标的起始位置截取一段元素形成一个新的集合，截取时，包含开始的索引不包含结束时的索引
    List&lt;String&gt; subList = list.subList(2,4);//截取索引下标大于等于2小于4的元素

    System.out.println(subList);

    System.out.println(list.size());//集合的长度
}
}</code></pre><h4 id="ArrayList-和-Vector"><a href="#ArrayList-和-Vector" class="headerlink" title="ArrayList 和 Vector"></a>ArrayList 和 Vector</h4><p>ArrayList 和 Vector 是 List 接口的两个典型实现<br>区别：</p>
<ul>
<li>Vector是一个古老的集合，通常建议使用 ArrayList</li>
<li>ArrayList 是线程不安全的，而 Vector 是线程安全的。</li>
</ul>
<blockquote>
<p>即使为保证 List 集合线程安全，也不推荐使用 Vector</p>
</blockquote>
<hr>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值，一组值用于保存 Map 里的 Key，另外一组用于保存 Map 里的 Value</p>
<p>Map 中的 key 和  value 都可以是任何引用类型的数据</p>
<p>Map 中的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较中返回 false</p>
<p>Key 和 Value 之间存在单向一对一关系，即通过指定的 Key 总能找到唯一的，确定的 Value。</p>
<p>例子：</p>
<pre><code>package day10;

import day09.Employee;

import java.security.KeyStore;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * @package: day10
 * @className: Test6
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/9 21:18
 * @version: 1.0
 */
public class Test6 {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();

        map.put(&quot;b&quot;,1);//添加数据
        map.put(&quot;c&quot;,2);
        map.put(&quot;e&quot;,2);
        System.out.println(map);

        System.out.println(map.get(&quot;b&quot;));//根据key取值

        map.remove(&quot;c&quot;);//根据key移除键值对
        System.out.println(map);

        System.out.println(map.size());//map集合的长度

        System.out.println(map.containsKey(&quot;a&quot;));//判断当前的map集合是否包含指定的key

        System.out.println(map.containsValue(10));//判断当前的map集合是否包含指定的value

//        map.clear();//清空集合

        Set&lt;String&gt; keys = map.keySet();//获取map集合的key的集合

        map.values();//获取集合的所有value值

        //遍历map集合,通过map.keySet();
        for (String key : keys){
            System.out.println(&quot;key&quot;+ key + &quot;, value:&quot;+map.get(key));
        }


        //通过map.entrySet();
        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrys = map.entrySet();
        for (Map.Entry&lt;String,Integer&gt; en : entrys ){
            System.out.println(&quot;key&quot;+ en.getKey() + &quot;, value:&quot;+en.getValue());
        }
    }
}</code></pre><h4 id="Map-接口与HashMap类"><a href="#Map-接口与HashMap类" class="headerlink" title="Map 接口与HashMap类"></a>Map 接口与HashMap类</h4><p><img data-sizes="auto" data-src="/images/JavaStudyData/java106.png" alt="" class="lazyload"></p>
<h4 id="HashMap-amp-Hashtable"><a href="#HashMap-amp-Hashtable" class="headerlink" title="HashMap &amp; Hashtable"></a>HashMap &amp; Hashtable</h4><p>HashMap 和 Hashtable 是 Map 接口的两个典型实现类<br>区别：</p>
<ul>
<li>Hashtable 是一个古老的 Map 实现类，不建议使用</li>
<li>Hashtable 是一个线程安全的 Map 实现，但 HashMap 是线程不安全的。</li>
<li>Hashtable 不允许使用 null 作为 key 和 value，而 HashMap 可以<br>与 HashSet 集合不能保证元素的顺序一样，Hashtable 、HashMap 也不能保证其中 key-value 对的顺序</li>
</ul>
<p>Hashtable 、HashMap 判断两个 Key 相等的标准是：两个 Key 通过 equals 方法返回 true，hashCode 值也相等。</p>
<p>Hashtable 、相等的标准是：两个 Value 通过 equalHashMap 判断两个 Values 方法返回 true</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><pre><code>Map&lt;Integer,String&gt; map = new TreeMap&lt;Integer,String&gt;();
   map.put(4,&quot;a&quot;);
   map.put(2,&quot;a&quot;);
   map.put(3,&quot;a&quot;);
   map.put(1,&quot;a&quot;);

   System.out.println(map);
   //TreeMap的自然排序是字典排序
   Map&lt;String,String&gt; map1 = new TreeMap&lt;String,String&gt;();
   map1.put(&quot;b&quot;,&quot;b&quot;);
   map1.put(&quot;c&quot;,&quot;b&quot;);
   map1.put(&quot;d&quot;,&quot;b&quot;);
   map1.put(&quot;a&quot;,&quot;b&quot;);
   map1.put(&quot;ab&quot;,&quot;ab&quot;);
   map1.put(&quot;1&quot;,&quot;b&quot;);
   map1.put(&quot;10&quot;,&quot;b&quot;);

   System.out.println(map1);</code></pre><p>TreeMap 存储 Key-Value 对时，需要根据 Key 对 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</p>
<p>TreeMap 的 Key 的排序：</p>
<ul>
<li>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li>定制排序（了解）：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li>
</ul>
<hr>
<h3 id="操作集合的工具类：Collections"><a href="#操作集合的工具类：Collections" class="headerlink" title="操作集合的工具类：Collections"></a>操作集合的工具类：Collections</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类</p>
<p>Collections 中提供了大量方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
<p>排序操作：</p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<pre><code>Object min(Collection)
Object min(Collection，Comparator)</code></pre><p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<p>例子：</p>
<pre><code>package day10;

import java.util.*;

/**
 * @package: day10
 * @className: Test7
 * @author: MingWill
 * @description: TODO
 * @date: 2022/8/9 22:04
 * @version: 1.0
 */
public class Test7 {
    public static void main(String[] args) {
          List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;b&quot;);
        list.add(&quot;cd&quot;);
        list.add(&quot;ca&quot;);
        list.add(&quot;aa&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;1&quot;);

        System.out.println(list);

        Collections.reverse(list);//反转list中的元素顺序
        System.out.println(list);

        Collections.shuffle(list);//对list集元素进行随机排序
        System.out.println(list);

        Collections.sort(list);//list集合字典升序排序
        System.out.println(list);

        Collections.swap(list,0,4);//指定位置的元素交换，将i处元素与J处元素进行交换
        System.out.println(list);

        System.out.println(Collections.frequency(list,&quot;a&quot;));//返回指定集合中指定元素的出现次数

        Collections.replaceAll(list,&quot;a&quot;,&quot;aa&quot;);//使用新值替换 List 对象的所有旧值
        System.out.println(list);

//        System.out.println(Collections.max(list));//返回最大值
//        System.out.println(Collections.min(list));//返回最小值
//
//        Student s1= new Student(14,&quot;张三&quot;);
//
//        List&lt;Student&gt; stus = new ArrayList&lt;&gt;();
//        stus.add(s1);
//        stus.add(s2);
//        stus.add(s3);
//        stus.add(s4);
//
//
//        //根据 Comparator 指定的顺序，返回给定集合中的最大元素
//        Student s = Collections.max(stus,new Student());
//        System.out.println(s.name + &quot;,&quot; + s.age);
//
//        //根据 Comparator 指定的顺序，返回给定集合中的最小元素
//        Student ss = Collections.min(stus,new Student());
//        System.out.println(ss.name + &quot;,&quot; + ss.age);

//        for (Student stu : stus){
//            System.out.println(stu.name +&quot;,&quot;+ stu.age);
//        }
//
//        Collections.sort(stus,new Student());
//        System.out.println(&quot;____________________________&quot;);
//
//        for (Student stu : stus){//对指定的对象进行排序
//            System.out.println(stu.name +&quot;,&quot;+ stu.age);
//        }

    }
}

class Student implements Comparator&lt;Student&gt;{
    int age;
    String name;

    public Student(){

    }

    public Student(int age,String name){
        this.age = age;
        this.name = name;
    }
    @Override
    public int compare(Student o1, Student o2) {//根据年龄升序排列对象
       if (o1.age &gt; o2.age){
           return 1;
       }else if (o1.age &lt; o2.age){
           return -1;
       }else {
           return 0;
       }
    }
}</code></pre><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<p><img data-sizes="auto" data-src="/images/JavaStudyData/java107.png" alt="" class="lazyload"></p>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>非酋囧菌<br>
    <strong>本文链接：</strong><a href="http://yoursite.com/2022/08/06/JavaDay10.html/" title="http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;08&#x2F;06&#x2F;JavaDay10.html&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;yoursite.com&#x2F;2022&#x2F;08&#x2F;06&#x2F;JavaDay10.html&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'MingWill-Marvel.github.io',
        owner: 'MingWill-Marvel',
        admin: 'MingWill-Marvel'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1660572297314"></script>
  






</body>

</html>
