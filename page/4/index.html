<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>火星环游日记</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta property="og:type" content="website">
<meta property="og:title" content="火星环游日记">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="火星环游日记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="零点坠落">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1655138624902">
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/logo/a1.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="零点坠落" class="mdui-btn mdui-btn-icon"><img src="/images/logo/a3.jpg" alt="零点坠落"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="零点坠落">
            <img src="/images/logo/a3.jpg" alt="零点坠落" alt="零点坠落">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>59</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的基友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的基友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/33638990" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">47</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 零点坠落
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2020/08/05/java0805.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="Java工具篇之使用freeMarker生成word模板（小白篇）" class="lazyload">
                    <h1>Java工具篇之使用freeMarker生成word模板（小白篇）</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 12 分钟</a>
        </div>

        <article>
            
                <p>FreeMarker是一个很值得去学习的模版引擎。它是基于模板文件生成其他文本的通用工具,能生成各种文本，如html，xml，java，这段时间接触到一个新的需求-将word文件用模板方式自动生成，由于本身是个小白，且考虑到word中表格的遍历问题，这里以一个小白的方式来叙述完整的工程以及遇到的一些问题…..</p>
<h4 id="一、FreeMarker基本描述"><a href="#一、FreeMarker基本描述" class="headerlink" title="一、FreeMarker基本描述"></a>一、FreeMarker基本描述</h4><pre><code>FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。

特点：

1. 轻量级模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中

2. 能生成各种文本，如html，xml，java，等

3. 入门简单，它是用java编写的，很多语法和java相似</code></pre><h6 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h6><p><img data-sizes="auto" data-src="https://cdn.bootwiki.com/upload/note/20190903/20190903092928_69524.png" alt="" class="lazyload"></p>
<h4 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h4><p>需求：编写一个可以通过模板生成word文件的工具类，同时往word表格中添加特定的数据。</p>
<p>思考使用的方法：在Java中我所知生成导出word文件的方案有5种。</p>
<blockquote>
<p>1：Jacob是Java-COM Bridge的缩写，它在Java与微软的COM组件之间构建一座桥梁。通过Jacob实现了在Java平台上对微软Office的COM接口进行调用。    </p>
<ul>
<li>优点：调用微软Office的COM接口，生成的word文件格式规范。</li>
<li>缺点：服务器只能是windows平台，不支持unix和linux，且服务器上必须安装微软Office。</li>
</ul>
</blockquote>
<blockquote>
<p>2：Apache POI包括一系列的API，它们可以操作基于MicroSoft OLE 2 Compound Document Format的各种格式文件，可以通过这些API在Java中读写Excel、Word等文件。</p>
<ul>
<li>优点：跨平台支持windows、unix和linux。</li>
<li>缺点：相对与对word文件的处理来说，POI更适合excel处理，对于word实现一些简单文件的操作凑合，不能设置样式且生成的word文件格式不够规范。</li>
</ul>
</blockquote>
<blockquote>
<p>3：Java2word是一个在java程序中调用 MS Office Word 文档的组件(类库)。该组件提供了一组简单的接口，以便java程序调用他的服务操作Word 文档。 这些服务包括： 打开文档、新建文档、查找文字、替换文字，插入文字、插入图片、插入表格，在书签处插入文字、插入图片、插入表格等。</p>
<ul>
<li>优点：足够简单，操作起来要比FreeMarker简单的多。</li>
<li>缺点：没有FreeMarker强大，不能够根据模版生成Word文档，word的文档的样式等信息都不能够很好的操作。</li>
</ul>
</blockquote>
<blockquote>
<p>4：FreeMarker生成word文档的功能是由XML+FreeMarker来实现的。先把word文件另存为xml，在xml文件中插入特殊的字符串占位符，将xml翻译为FreeMarker模板，最后用java来解析FreeMarker模板，编码调用FreeMarker实现文本替换并输出Doc。</p>
</blockquote>
<blockquote>
<ul>
<li>优点：比Java2word功能强大，也是纯Java编程。</li>
<li>缺点：生成的文件本质上是xml，不是真正的word文件格式，有很多常用的word格式无法处理或表现怪异，比如：超链、换行、乱码、部分生成的文件打不开等。</li>
</ul>
</blockquote>
<blockquote>
<p>5：PageOffice生成word文件。PageOffice封装了微软Office繁琐的vba接口，提供了简洁易用的Java编程对象，支持生成word文件，同时实现了在线编辑word文档和读取word文档内容。</p>
<ul>
<li>优点：跨平台支持windows、unix和linux，生成word文件格式标准，支持文本、图片、表格、字体、段落、颜色、超链、页眉等各种格式的操作，支持多word合并，无需处理并发，不耗费服务器资源，运行稳定。</li>
<li>缺点：必须在客户端生成文件（可以不显示界面），不支持纯服务器端生成文件。</li>
</ul>
</blockquote>
<p>由于考虑到易用性，以及模板数量不多，于是使用freeMarker方案来写。</p>
<hr>
<h5 id="实现流程："><a href="#实现流程：" class="headerlink" title="实现流程："></a>实现流程：</h5><p>1.创建一个maven项目并导入FreeMarker Jar包（为项目添加依赖）</p>
<pre><code>        &lt;dependency&gt;
    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
    &lt;version&gt;2.3.23&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;dom4j&lt;/groupId&gt;
    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jaxen&lt;/groupId&gt;
    &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
    &lt;version&gt;1.1.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>1.word中数据项点的自动参数匹配,将word中需要插入数据的内容替换为对应的${xxx}，方法名 replaceDocumentBychr</p>
<p>例如：<br><img data-sizes="auto" data-src="/images/Java15/Java15_3.PNG" alt="" class="lazyload"></p>
<p>2.word中表格前后添加freemaker &lt;#list&gt;标签，通过迭代的方式解决list循环问题，方法名 addListDocumentForTable</p>
<p>例如：<br><img data-sizes="auto" data-src="/images/Java15/Java15_4.PNG" alt="" class="lazyload"></p>
<h6 id="XmlModelUtils-java-Xml工具封装类"><a href="#XmlModelUtils-java-Xml工具封装类" class="headerlink" title="XmlModelUtils.java (Xml工具封装类)"></a>XmlModelUtils.java (Xml工具封装类)</h6><pre><code>package com.huajie.utils.word;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.dom4j.*;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;


public class XmlModelUtils {

private File inputXml;

private static int i =0;

private static int tableIndex =0;

private static List listParamCode = new ArrayList&lt;String&gt;();

private static List listTableName = new ArrayList&lt;String&gt;();

public XmlModelUtils(File inputXml) {
   this.inputXml = inputXml;
}

public static void main(String[] argv) throws DocumentException, IOException {
    for (int j = 0; j &lt;102 ; j++) {
        listParamCode.add(&quot;leadergroup_&quot;+j+&quot;&quot;);
    }

    for (int j = 0; j &lt;14 ; j++) {
        listTableName.add(&quot;list&quot;+j+&quot;&quot;);
    }


    XmlModelUtils dom4jParser = new XmlModelUtils(new File(&quot;D:\\qrcodetmp\\freemaker.xml&quot;));
    Document document = dom4jParser.getDocument();
    //将所有的**替换为对应的值
    dom4jParser.replaceDocumentBychr(document.getRootElement());
    //在所有的table前后增加freemaker list标签
    dom4jParser.addListDocumentForTable(document);

    XMLWriter output = new XMLWriter(new FileWriter(new File(
            &quot;D:\\qrcodetmp\\students-modified.ftl&quot;)));
    output.setEscapeText(false);
    output.write(document);
    output.close();

 }

private void addListDocumentForTable(Document document) {
    document.getRootElement().addNamespace(&quot;w&quot;,&quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;);
    List nodes =  document.getRootElement().selectNodes(&quot;//w:tbl&quot;);
    Iterator iter = nodes.iterator();
    while (iter.hasNext()) {
        tableIndex++;
        Element element = (Element) iter.next();
        Iterator iterator = element.elementIterator(&quot;tr&quot;);
        while (iterator.hasNext()) {
            Element nameElement = (Element) iterator.next();
            if(!iterator.hasNext()){
                Element currentElement = nameElement;
                Element pNode = nameElement.getParent();
                pNode.remove(nameElement);
                Element listElementHead = pNode.addElement(&quot;w:r&quot;);
                listElementHead.setText(&quot;&lt;#list &quot;+listTableName.get(tableIndex-1)+&quot; as &quot;+listTableName.get(tableIndex-1)+&quot; &gt; &quot;);
//                    listElementHead.setText(&quot;&lt;#list listLeadergroup as listLeadergroup&gt;&quot;);
                pNode.add(currentElement);
                Element listElementTail = pNode.addElement(&quot;w:r&quot;);
                listElementTail.setText(&quot;&lt;/#list&gt;&quot;);
            }
        }
    }
    document.getRootElement().remove(new Namespace(&quot;w&quot;,&quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;));
}


public Document getDocument() {
    SAXReader saxReader = new SAXReader();
    Document document = null;
    try {
        document = saxReader.read(inputXml);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return document;
 }

public void replaceDocumentBychr(Element element) {
    // 枚举根节点下所有子节点
    for (Iterator ie = element.elementIterator(); ie.hasNext();) {
        Element elementa = (Element) ie.next();
        // 枚举当前节点下所有子节点
        for (Iterator ieson = elementa.elementIterator(); ieson.hasNext();) {
            Element elementSon = (Element) ieson.next();
            if(elementSon.getText().contains(&quot;*&quot;)){
//                    System.out.println(elementSon.getName() + &quot;:&quot;+ elementSon.getText());
                String textNew = replaceText(elementSon.getText());
                elementSon.setText(textNew);
            }
        }
        replaceDocumentBychr(elementa);
    }
}

public String replaceText(String text){
    Integer cnt = getCountByChr(text,&quot;**&quot;);
    Integer index = text.indexOf(&quot;**&quot;);
    i++;
    if(cnt&gt;1){
        text = text.substring(0,index+2).replace(&quot;**&quot;,&quot;${&quot;+listParamCode.get(i-1)+&quot;}&quot;)+text.substring(index+2);
        return replaceText(text);
    }else{
        text = text.replace(&quot;**&quot;,&quot;${&quot;+listParamCode.get(i-1)+&quot;}&quot;);
    }

    return text;
}

private Integer getCountByChr(String text, String chr) {
    int count = 0;
    int index;
    //先查，赋值，判断
    while((index=text.indexOf(chr))!=-1){
        count++;
        text = text.substring(index + chr.length());
    }
    return count;
   }
}</code></pre><p>按照以下格式对ftl文档进行替换：</p>
<h6 id="WordAction-java（word业务处理类）"><a href="#WordAction-java（word业务处理类）" class="headerlink" title="WordAction.java（word业务处理类）"></a>WordAction.java（word业务处理类）</h6><pre><code>package com.freemarker.docx;


import lombok.Data;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.*;

@Data
public class WordAction {

private String filePath;   //文件路径
private String fileName;   //文件名称
private String fileOnlyName;   //文件唯一名称


public String createWord() {
/** 用于组装word页面需要的数据 */
Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;();

/** 组装数据 */

//迭代map
dataMap.put(&quot;borrower&quot;, &quot;李四&quot;);
dataMap.put(&quot;sex&quot;, &quot;男&quot;);
dataMap.put(&quot;age&quot;, &quot;27&quot;);
dataMap.put(&quot;maritalStat&quot;, &quot;已婚&quot;);
dataMap.put(&quot;phone&quot;, &quot;18880881231&quot;);
dataMap.put(&quot;idcard&quot;, &quot;360724199402307841&quot;);

dataMap.put(&quot;homeAddr&quot;, &quot;江西省赣州市章贡区蟠龙镇118号&quot;);
dataMap.put(&quot;appBank&quot;, &quot;中国建设银行&quot;);
dataMap.put(&quot;appAmt&quot;, &quot;200000&quot;);
dataMap.put(&quot;appTerm&quot;, &quot;12&quot;);

 //迭代第一组list
List&lt;LoanRel&gt; loanRels = new ArrayList&lt;LoanRel&gt;();
loanRels.add(new LoanRel(&quot;小李&quot;, &quot;朋友&quot;, &quot;农业机械公司&quot;, &quot;技术员&quot;, 34324324));
 loanRels.add(new LoanRel(&quot;小刘&quot;, &quot;朋友&quot;, &quot;化肥站&quot;, &quot;操作员&quot;, 34324324));
loanRels.add(new LoanRel(&quot;小明&quot;, &quot;朋友&quot;, &quot;饲料厂&quot;, &quot;技术员&quot;, 34324324));
dataMap.put(&quot;loanRels&quot;,loanRels);

 //迭代第二组list
List&lt;LoanBusi&gt; loanBusis = new ArrayList&lt;LoanBusi&gt;();
 loanBusis.add(new LoanBusi(&quot;脐橙种植&quot;,100));
 loanBusis.add(new LoanBusi(&quot;脐橙种植&quot;,100));
 loanBusis.add(new LoanBusi(&quot;脐橙种植&quot;,100));

/** 文件名称，唯一字符串 */
Random r = new Random();
//获取当前时间
SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyMMdd&quot;);
StringBuffer dx = new StringBuffer();
//动态字符串数组追加
dx.append(sdf1.format(new Date()));
dx.append(&quot;_&quot;);
dx.append(r.nextInt(100));

//文件路径
filePath = &quot;D:/word2007/&quot;;

//文件唯一名称
fileOnlyName = &quot;用freemarker生成Word文档_&quot; + dx + &quot;.doc&quot;;

//文件名称
fileName = &quot;用freemarker生成Word文档.doc&quot;;

/** 生成word */
WordUtil.createWord(dataMap, &quot;farmer.ftl&quot;, filePath, fileOnlyName);

return &quot;createWordSuccess&quot;;
}


/**
* 下载生成的word文档
*/
public String dowloadWord() {
/** 先判断文件是否已生成  */
try {
//解决中文乱码
filePath = URLDecoder.decode(filePath, &quot;UTF-8&quot;);
fileOnlyName = URLDecoder.decode(fileOnlyName, &quot;UTF-8&quot;);
fileName = URLDecoder.decode(fileName, &quot;UTF-8&quot;);

//如果文件不存在，则会跳入异常，然后可以进行异常处理
new FileInputStream(filePath + File.separator + fileOnlyName);
} catch (Exception e) {
e.printStackTrace();
return &quot;error&quot;;
}
return &quot;dowloadWord&quot;;
}

/**
* 返回最终生成的word文档 文件流
* 下载生成的word文档
*/
public InputStream getWordFile() {
try {
//解决中文乱码
fileName = URLDecoder.decode(fileName, &quot;UTF-8&quot;);

/** 返回最终生成的word文件流  */
return new FileInputStream(filePath + File.separator + fileOnlyName);
} catch (Exception e) {
e.printStackTrace();
return null;
}
}

public static void main(String[] args) throws Exception {
new WordAction().createWord();
}
}</code></pre><h6 id="WordUtil-java-word工具类"><a href="#WordUtil-java-word工具类" class="headerlink" title="WordUtil.java(word工具类)"></a>WordUtil.java(word工具类)</h6><pre><code>package com.huajie.utils.word;

import freemarker.template.Configuration;
import freemarker.template.Template;

import java.io.*;
import java.util.Map;

public class WordUtil {

/**
 * 生成word文件
 * @param dataMap word中需要展示的动态数据，用map集合来保存
 * @param templateName word模板名称，例如：test.ftl
 * @param filePath 文件生成的目标路径，例如：D:/wordFile/
 * @param fileName 生成的文件名称，例如：test.doc
 */
@SuppressWarnings(&quot;unchecked&quot;)
public static void createWord(Map dataMap,String templateName,String filePath,String fileName){
    try {
        //创建配置实例
        Configuration configuration = new Configuration();

        //设置编码
        configuration.setDefaultEncoding(&quot;UTF-8&quot;);

        //ftl模板文件
//            configuration.setClassForTemplateLoading(WordUtil.class,&quot;/&quot;);
        configuration.setDirectoryForTemplateLoading(new File(&quot;D:/qrcodetmp/&quot;));
        //获取模板
        Template template = configuration.getTemplate(templateName);

        //输出文件
        File outFile = new File(filePath+File.separator+fileName);

        //如果输出目标文件夹不存在，则创建
        if (!outFile.getParentFile().exists()){
            outFile.getParentFile().mkdirs();
        }

        //将模板和数据模型合并生成文件
        Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFile),&quot;UTF-8&quot;));


        //生成文件
        template.process(dataMap, out);

        //关闭流
        out.flush();
        out.close();
    } catch (Exception e) {
        e.printStackTrace();
     }
   }
 }</code></pre><p>生成结果：</p>
<p><img data-sizes="auto" data-src="/images/Java15/Java15_1.PNG" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="/images/Java15/Java15_2.PNG" alt="" class="lazyload"></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/08/03/JavaReuqestBody.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="RequestBody的使用" class="lazyload">
                    <h1>RequestBody的使用</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年08月03日</a>
            <a><i class="nexmoefont icon-areachart"></i>941 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
        </div>

        <article>
            
                <p>@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/28/Java0728.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="如何正确的crud" class="lazyload">
                    <h1>如何正确的crud</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>0 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <a id="more"></a>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/24/JavaSingletenPattern.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="http://5b0988e595225.cdn.sohucs.com/images/20190418/47658e88f01a43d5b520242152262ddb.jpeg" data-sizes="auto" alt="SpringCloud各层框架注解简述" class="lazyload">
                    <h1>SpringCloud各层框架注解简述</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月24日</a>
            <a><i class="nexmoefont icon-areachart"></i>2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 8 分钟</a>
        </div>

        <article>
            
                <p>单例模式（SingletenPattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方法，本文我将通过资料以及自己的理解详细梳理对单例模式的运用和理解。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/24/JavaSingletenPattern.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="http://5b0988e595225.cdn.sohucs.com/images/20190418/47658e88f01a43d5b520242152262ddb.jpeg" data-sizes="auto" alt="Java设计模式之单例模式" class="lazyload">
                    <h1>Java设计模式之单例模式</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月24日</a>
            <a><i class="nexmoefont icon-areachart"></i>2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 8 分钟</a>
        </div>

        <article>
            
                <p>单例模式（SingletenPattern）是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方法，本文我将通过资料以及自己的理解详细梳理对单例模式的运用和理解。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/15/Java0715.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="Synchronized 解析" class="lazyload">
                    <h1>Synchronized 解析</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月15日</a>
            <a><i class="nexmoefont icon-areachart"></i>130 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。<br>任何技术的出现都是为了解决某一类问题，如果在此基础上再建立奇技淫巧，不如回归Java本身，应该保持合理使用而不滥用。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/09/Java0709.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="Linu常用手册" class="lazyload">
                    <h1>Linu常用手册</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月09日</a>
            <a><i class="nexmoefont icon-areachart"></i>5.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 24 分钟</a>
        </div>

        <article>
            
                <p>Linux命令归档，方便回顾和记忆</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/07/Java0707.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="Mybatis 工作原理" class="lazyload">
                    <h1>Mybatis 工作原理</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月07日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 21 分钟</a>
        </div>

        <article>
            
                <p>最近项目要用到mybatis-puls,在学习mybatis-puls一定得先重新了解一下mybatis的工作原理，那让我们回顾一下mybatis是如何工作的吧！</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/04/Java0704.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="乐观锁和悲观锁" class="lazyload">
                    <h1>乐观锁和悲观锁</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月04日</a>
            <a><i class="nexmoefont icon-areachart"></i>364 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>当程序中可能出现并发的情况时，就需要通过一定的手段来保证在并发的情况下数据的准确性，通过这种手段保证了当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/07/01/Java0701.html/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/images/logo/a1.jpg" data-sizes="auto" alt="Java 8 方法引用" class="lazyload">
                    <h1>Java 8 方法引用</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年07月01日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 6 分钟</a>
        </div>

        <article>
            
                <p>我们用Lambda表达式来实现匿名方法。但有些情况下，我们用Lambda表达式仅仅是调用一些已经存在的方法，除了调用动作外，没有其他任何多余的动作，在这种情况下，我们倾向于通过方法名来调用它，而Lambda表达式可以帮助我们实现这一要求，它使得Lambda在调用那些已经拥有方法名的方法的代码更简洁、更容易理解。方法引用可以理解为Lambda表达式的另外一种表现形式。</p>
            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
      <a class="extend prev" rel="prev" href="/page/3/"><i class="nexmoefont icon-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1655138624903"></script>
  





</body>

</html>
