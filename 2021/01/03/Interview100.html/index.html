<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Java面试突击一百道 - 火星环游日记</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="01.谈谈你对面向对象思想的理解首先，谈谈“面向过程”和”面向对象“ 我觉得这两者主要是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以”组织者“的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以”面向过程”的思维，我更多是关注如何设计一个算法，然后保证比较均衡的产生0-10之间的随机数，而面向对象的思维下我更多的会关注，我应该找谁来帮我们做">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试突击一百道">
<meta property="og:url" content="http://yoursite.com/2021/01/03/Interview100.html/index.html">
<meta property="og:site_name" content="火星环游日记">
<meta property="og:description" content="01.谈谈你对面向对象思想的理解首先，谈谈“面向过程”和”面向对象“ 我觉得这两者主要是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以”组织者“的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以”面向过程”的思维，我更多是关注如何设计一个算法，然后保证比较均衡的产生0-10之间的随机数，而面向对象的思维下我更多的会关注，我应该找谁来帮我们做">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-199da3b71771a2ac8a6abca871d2bca2_720w.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20170729110914749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1OTYxNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic2.zhimg.com/v2-64837bba450a2a0cdcda96ae50bae445_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-b4e97b3a0ae3c0b5fcf7d0ee4cffb1a7_b.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-4c7a884cf36dc1e2299457de80436082_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-7358b2a3ff8ecaea6c75f3263618893f_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-7358b2a3ff8ecaea6c75f3263618893f_b.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-36ae97b8f5cfda5820465fc54c3530e9_b.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-3e8867ea1ca71f0aefa2c48680a2288e_b.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-3640b7f86a072bc188199aa8bb76c271_b.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-4423b8f2855af708b62c1c167b432ca0_b.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-744604fac1b53e491e63a1a4c1f3ba34_b.jpg">
<meta property="article:published_time" content="2021-01-02T17:01:37.000Z">
<meta property="article:modified_time" content="2021-03-02T13:52:45.000Z">
<meta property="article:author" content="零点坠落">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic3.zhimg.com/80/v2-199da3b71771a2ac8a6abca871d2bca2_720w.jpg">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1655133146714">
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/logo/a1.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="零点坠落" class="mdui-btn mdui-btn-icon"><img src="/images/logo/a3.jpg" alt="零点坠落"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="零点坠落">
            <img src="/images/logo/a3.jpg" alt="零点坠落" alt="零点坠落">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>57</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的基友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的基友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/33638990" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">47</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 零点坠落
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: NaN%;"> 
          <img data-src="/images/java1/b1.jpg" data-sizes="auto" alt="Java面试突击一百道" class="lazyload">
          <h1>Java面试突击一百道</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年01月03日</a>
    <a><i class="nexmoefont icon-areachart"></i>9.3k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 40 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <a id="more"></a>

<h3 id="01-谈谈你对面向对象思想的理解"><a href="#01-谈谈你对面向对象思想的理解" class="headerlink" title="01.谈谈你对面向对象思想的理解"></a>01.谈谈你对面向对象思想的理解</h3><p>首先，谈谈“面向过程”和”面向对象“</p>
<p>我觉得这两者主要是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以”组织者“的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以”面向过程”的思维，我更多是关注如何设计一个算法，然后保证比较均衡的产生0-10之间的随机数，而面向对象的思维下我更多的会关注，我应该找谁来帮我们做这件事，比如Random类，调用其中提供的方法即可。</p>
<p>所以面向对象的思维更多的是考虑如何去选择合适的工具，然后组织到一起干一件事。</p>
<p>就好比一个导演，要拍一部电影，那么首先要有男主角和女主角，然后其他等等，最后把这些资源组织起来，拍成一部电影。</p>
<p>再回到我们的程序世界，这种组织者的思维无处不在，比如我们要开发项目，以三层架构的模式来开发，那么这个时候，我们不需要造轮子，只需要选择市面上主流的框架即可，比如SpringMVC，Spring，MyBatis等等，这些都是各层的主流框架。</p>
<hr>
<h3 id="02-并发编程我们需要关注哪些方面？"><a href="#02-并发编程我们需要关注哪些方面？" class="headerlink" title="02. 并发编程我们需要关注哪些方面？"></a>02. 并发编程我们需要关注哪些方面？</h3><p>主要有3个核心问题：分工，同步，互斥</p>
<p>分工：如何将任务拆分成多线程执行</p>
<p>将大任务拆分成不同职能的小任务交由不同的线程去执行，这样很多任务都是并发执行的大大缩减任务执行时间。</p>
<p>同步：线程之间如何协调</p>
<p>A任务执行完后，才能进行B任务，任务的执行需要各线程的协调</p>
<p>互斥：如何保证同一时间只允许一个线程访问同一资源</p>
<p>当多岔路口的车需要进入同一个入口时，便需要依次排队进入。</p>
<p>分工，同步关注的是性能问题，互斥关注的是安全问题</p>
<hr>
<h3 id="1-JDK-JRE-JVM有什么区别？"><a href="#1-JDK-JRE-JVM有什么区别？" class="headerlink" title="1.JDK,JRE,JVM有什么区别？"></a>1.JDK,JRE,JVM有什么区别？</h3><ul>
<li><p>JDK(Java DeveLopment Kit) Java开发工具包，提供了Java开发环境和运行环境。包含了编译Java源文件的编辑器Javac，还有调试和分析工具。</p>
</li>
<li><p>JRE(Java Runtime Environment) Java运行环境，包含Java虚拟机及一些基础类库。</p>
</li>
<li><p>JVM(Java Virtual Machine) Java虚拟机，提供执行字节码文件的能力。</p>
</li>
</ul>
<p>所以，如果只是运行Java程序,只需要安装JRE即可。</p>
<p>另外注意，JVM是实现Java跨平台的核心，但JVM本身是不能跨平台的，不同的平台需要安装相应的JVM。</p>
<p><img data-sizes="auto" data-src="https://pic3.zhimg.com/80/v2-199da3b71771a2ac8a6abca871d2bca2_720w.jpg" alt="" class="lazyload"></p>
<hr>
<h4 id="2-Java的基本数据类型有哪些？"><a href="#2-Java的基本数据类型有哪些？" class="headerlink" title="2. Java的基本数据类型有哪些？"></a>2. Java的基本数据类型有哪些？</h4><p>boolean，char，byte，short，int，long，float，double</p>
<p>而String是引用类型</p>
<p>它们的存储位置：</p>
<p><img data-sizes="auto" data-src="https://img-blog.csdn.net/20170729110914749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1OTYxNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" class="lazyload"></p>
<hr>
<h4 id="3-和equals的区别"><a href="#3-和equals的区别" class="headerlink" title="3. ==和equals的区别"></a>3. ==和equals的区别</h4><ul>
<li><p>== 比较的是值</p>
<blockquote>
<p>比较基本数据类型，比较的是数值</p>
</blockquote>
<blockquote>
<p>比较引用数据类型，比较的是引用所指的值（地址）</p>
</blockquote>
</li>
<li><p>equals 默认比较也是地址，这个方法最初是定义在Object上，默认的实现就是比较地址</p>
</li>
</ul>
<p>自定义的类，如何需要比较的是内容，那么就要学String，重写equals</p>
<p>案例：</p>
<pre><code>String s1 = new String(&quot;zs&quot;);
String s2 = new String(&quot;zs&quot;);
System.out.println(s1 == s2);

false
双方均new了对象

String s3 = &quot;zs&quot;;
String s4 = &quot;zs&quot;;
System.out.println(s3 == s4);

true
双方均指向常量池的地址

System.out.println(s3 == s1);

false
s3指向常量池的地址
s1指向的是对象引用的地址

String s5 = &quot;zszs&quot;;
String s6 = s3+s4;
System.out.println(s5 == s6);

false
s5指向常量池的地址
s6拼接变量，new了新对象

final String s7 = &quot;zs&quot;;
final String s8 = &quot;zs&quot;;
String s9 = s7+s8;
System.out.println(s5 == s9);

true
由于s7和s8都是常量，s9在运算时结果也会转变成常量
s9和s5均指向常量池的值（”zszs”）

final String s10 = s3+s4;
System.out.println(s5 == s10);

false
s10拼接变量指向引用的对象地址
s5指向常量池</code></pre><hr>
<h4 id="4-final的作用"><a href="#4-final的作用" class="headerlink" title="4. final的作用"></a>4. final的作用</h4><ul>
<li><p>final修饰类：表示类不可变，不可继承</p>
<p>比如，String，不可变性</p>
</li>
<li><p>final修饰方法：表示方法不可被重写</p>
<p>比如模板方法，可以固定我们的算法</p>
</li>
<li><p>final修饰变量：这个变量就是常量</p>
<p>注意：</p>
</li>
<li><p>修饰的是基本数据类型，这个值本身不能修改</p>
</li>
<li><p>修饰的是引用类型，引用的指向不能修改</p>
<p>比如下面的代码是可以的</p>
</li>
</ul>
<pre><code>fianl Student student = new Student(1,&quot;Andy&quot;);
student.setAge(18);        //注意这个是可以的！

//Student s2 = new Student(1,&quot;Tom&quot;);
//student = s2;            //注意这样是不可以的！</code></pre><p><strong>final修饰的对象内容是可以改变的，但是引用时不能内改变的，如果执行注释到的内容，将新生成的s2对象赋值给student的话就会报错。</strong></p>
<hr>
<h4 id="5，String-s-“java”与String-s-new-String-“java”"><a href="#5，String-s-“java”与String-s-new-String-“java”" class="headerlink" title="5，String s = “java”与String s = new String(“java”)"></a>5，String s = “java”与String s = new String(“java”)</h4><p>String s = “java”;</p>
<p>String s = new String(“java”);</p>
<p>这两者的内存分配方式是不一样的。</p>
<p>第一种方式，JVM会将其分配到常量池，而第二种方式是分配到堆内存</p>
<hr>
<h4 id="6-String-StringBuffer-StringBuilder区别"><a href="#6-String-StringBuffer-StringBuilder区别" class="headerlink" title="6. String, StringBuffer, StringBuilder区别"></a>6. String, StringBuffer, StringBuilder区别</h4><p>String 跟其他两个类的区别是</p>
<blockquote>
<p>String是final类型，每次声明的都是不可变对象，所以每次操作都会产生新的String对象，然后将指针指向新的String对象。</p>
</blockquote>
<p>StringBuffer,StringBuilder都是在原有对象上进行操作</p>
<blockquote>
<p>所以，如果需要经常改变字符串内容，则采用这两者。</p>
</blockquote>
<p>StringBuffer vs StringBuilder</p>
<blockquote>
<p>前者是线程安全的，后者是线程不安全的。</p>
</blockquote>
<blockquote>
<p>线程不安全性能更高，所以在开发中，优先采<br>用StringBuilder.</p>
</blockquote>
<blockquote>
<p>StringBuilder &gt; StringBuffer &gt; String</p>
</blockquote>
<p>开发中，你用StringBuilder来解决什么问题？</p>
<p>字符串拼接的问题：</p>
<p>方法内：</p>
<pre><code>StringBuilder sb = new StringBuilder();
sb.append(&quot;&quot;);</code></pre><p><strong>如果一个线程访问一个资源，你不用考虑线程安不安全，可以放心使用；如果多个线程访问一个资源，你才要考虑线程安不安全。</strong></p>
<hr>
<h4 id="7，接口和抽象类的区别"><a href="#7，接口和抽象类的区别" class="headerlink" title="7，接口和抽象类的区别"></a>7，接口和抽象类的区别</h4><ul>
<li>这个问题，要分JDK版本来区分回答：</li>
</ul>
<p>JDK1.8之前：</p>
<ul>
<li>语法：</li>
<li>抽象类：方法可以有抽象的，也可以有非抽象, 有构造器</li>
<li>接口：方法都是抽象，属性都是常量，默认有public static final修饰</li>
<li>设计：</li>
<li>抽象类：同一类事物的抽取，比如针对Dao层操作的封装，如，BaseDao，BaseServiceImpl</li>
</ul>
<ul>
<li>接口：通常更像是一种标准的制定，定制系统之间对接的标准<br>例子：</li>
</ul>
<ol>
<li>单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao</li>
<li>分布式项目，面向服务的开发，抽取服务service，这两个角色之间的纽带，依然是接口</li>
</ol>
<p>JDK1.8之后：</p>
<p>  接口里面可以有实现的方法，注意要在方法的声明上加上default或者static</p>
<p>最后区分几个概念：</p>
<pre><code>多继承，多重继承，多实现
多重继承：A-&gt;B-&gt;C（爷孙三代的关系）
多实现：Person implements IRunable,IEatable（符合多项国际化标准）
多继承：接口可以多继承，类只支持单继承      </code></pre><hr>
<h4 id="8-算法题-求N的阶乘"><a href="#8-算法题-求N的阶乘" class="headerlink" title="8. 算法题- 求N的阶乘"></a>8. 算法题- 求N的阶乘</h4><p>这道算法题一般考查的递归的编程技能，那么我们回顾下递归程序的特点：</p>
<p>1，什么是递归？  </p>
<pre><code>递归，就是方法内部调用方法自身</code></pre><p>  递归的注意事项：</p>
<pre><code>找到规律，编写递归公式
找到出口（边界值），让递归有结束边界
注意：如果递归太多层，或者没有正确结束递归，则会出现“栈内存溢出Error”！
问题：为什么会出现栈内存溢出，而不是堆内存溢出？</code></pre><ol start="2">
<li>这道题怎么写？</li>
</ol>
<p>规律： N! = (n-1)!*n</p>
<p>出口： n==1或n==0 return 1;</p>
<pre><code> public static int getResult(int n){
   if(n&lt;0){
     throw new ValidateException(&quot;非法参数&quot;)；
   }
   if(n==1 || n==0){
     return 1;
   }else{
   return getResult(n-1)*n;
}</code></pre><p>}</p>
<hr>
<h4 id="算法题-斐波那契数列的第n个数是几？"><a href="#算法题-斐波那契数列的第n个数是几？" class="headerlink" title="算法题-斐波那契数列的第n个数是几？"></a>算法题-斐波那契数列的第n个数是几？</h4><p>如何实现递归求斐波那切数列第N个数字的值（传说中的不死神兔就是这个问题）</p>
<p>数字的规律：1,1,2,3,5,8,13,21….</p>
<p>所以，我们可以分析编写如下：</p>
<p>   规则：每个数等于前两个数之和<br>   出口：第一项和第2项都等于1</p>
<pre><code>public staic int getFeiBo(int n){
  if(n&lt;0){
    throw new ValidateException(&quot;非法参数&quot;)；
  }
  if(n==1|| n==2){
    return 1;
  }else{
    return getFeiBo(n-2)+getFeiBo(n-1);
  }
}</code></pre><h4 id="9，Int和Integer的区别（重点）"><a href="#9，Int和Integer的区别（重点）" class="headerlink" title="9，Int和Integer的区别（重点）"></a>9，Int和Integer的区别（重点）</h4><p>1，来，先来一道考题，你看做对了吗？</p>
<pre><code>Integer i1 = new Integer(12);
Integer i2 = new Integer(12);
System.out.println(i1 == i2);

 false


Integer i3 = 126;
Integer i4 = 126;
int i5 = 126;
System.out.println(i3 == i4);
System.out.println(i3 == i5);

true
true


Integer i6 = 128;
Integer i7 = 128;
int i8 = 128;
System.out.println(i6 == i7);
System.out.println(i6 == i8);

false
false</code></pre><p>以上这些输出的答案是什么？true or false？ why？</p>
<p>你可以自己先思考，再看后面的答案分析。</p>
<p>答案揭晓</p>
<p>分情况来比较</p>
<ul>
<li>都定义为Integer的比较：</li>
</ul>
<p>new：一旦new，就是开辟一块新内存，结果肯定是false</p>
<p>不new：看范围Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等当不在这个范围，内部创建新的对象，此时不相等</p>
<p>*Integer和int的比较：</p>
<p>实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较此时跟是否在缓存范围内或是否new都没关系</p>
<p>源码分析：</p>
<blockquote>
<p>当我们写Integer i = 126,实际上做了自动装箱：Integer i = Integer.valueOf(126);</p>
</blockquote>
<p>分析这段源码</p>
<pre><code>public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
//IntegerCache是Integer的内部类
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];
    static {
        // high value may be configured by     property
        int h = 127;​​</code></pre><hr>
<h4 id="12，方法的重写和重载的区别"><a href="#12，方法的重写和重载的区别" class="headerlink" title="12，方法的重写和重载的区别"></a>12，方法的重写和重载的区别</h4><p>重载：</p>
<ul>
<li>发生在一个类里面，方法名相同，参数列表不同（混淆点：跟返回类型没关系）</li>
</ul>
<p>以下不构成重载</p>
<p>public double add(int a,int b)</p>
<p>public int add(int a,int b)​</p>
<p>重写：</p>
<ul>
<li>发生在父类子类之间的，方法名相同，参数列表相同</li>
</ul>
<h4 id="List和set的区别"><a href="#List和set的区别" class="headerlink" title="List和set的区别"></a>List和set的区别</h4><ul>
<li>List(列表)：有序的，可重复的</li>
</ul>
<p>ArrayList LinkedList</p>
<p>List存放的对象是有序可重复的，List关注的是索引，拥有一系列和索引有关的方法，查询速度快，插入删除速度慢</p>
<ul>
<li>set(集)：无序的，不可重复的</li>
</ul>
<p>HashSet TreeSet</p>
<p>集合中的对象是不按特定的方式排序，只是简单地把对象加入集合</p>
<ul>
<li>map(映射)：键值对，键唯一，值不唯一</li>
</ul>
<p>对map集合遍历时先得到键的set集合，对set集合进行遍历得到相应的值。</p>
<h4 id="16-谈谈ArrayList和LinkedList的区别"><a href="#16-谈谈ArrayList和LinkedList的区别" class="headerlink" title="16.谈谈ArrayList和LinkedList的区别"></a>16.谈谈ArrayList和LinkedList的区别</h4><ul>
<li>ArrayList 数组 连续一块内存空间</li>
<li>LinkedList 双向链表，不是连续的内存空间</li>
</ul>
<p>Arraylist，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移。</p>
<p>LinkedList,查找慢，因为需要通过指针一个个查找，但删除，插入快，因为只要改变前后节点的指针指向即可。</p>
<h4 id="17-SpringIOC"><a href="#17-SpringIOC" class="headerlink" title="17. SpringIOC"></a>17. SpringIOC</h4><p>1.谈谈SpringIOC的理解</p>
<p>控制反转，将对象创建的任务由程序员本身转向容器。</p>
<ol start="2">
<li><p>谈谈springIOC的应用场景</p>
</li>
<li><p>说说如何实现IOC容器<br>知道找你们实现</p>
</li>
</ol>
<p>完成两件事</p>
<ol>
<li>解析</li>
<li>实现复制</li>
</ol>
<p>配置文件的方式</p>
<ol>
<li>解析XML —-&gt; Dom4j</li>
<li>调用方法，实现注入（反射）</li>
</ol>
<p>注解的方式</p>
<ol>
<li>解析类</li>
</ol>
<p>这个类是归spring管理<br>获取到类的注解信息和属性的注解信息（反射）<br>2. 赋值</p>
<p>使用方式：<br>1.配置文件的方式<br><bean><br>   <agrs>/<agrs><br><bean></p>
<pre><code>public class UserController{
  pubic void setUserService(IuserService userService){
    this.userService = userService;
  }
 }</code></pre><p>2.注解的方式</p>
<pre><code>@Controller
class  UserController{
  @Autowrie
  private IUserService userService;
}
@Service
class UserService1 implements IUserService{}

@Service
class UserService2 implements IUserService{}</code></pre><h4 id="17，如何在双向链表A和B之间插入C？"><a href="#17，如何在双向链表A和B之间插入C？" class="headerlink" title="17，如何在双向链表A和B之间插入C？"></a>17，如何在双向链表A和B之间插入C？</h4><p>可以使用伪代码的方式来实现，你的答案是什么？</p>
<p>假设我们定位到了A节点，那么A.next就是B节点，这个是前提。</p>
<pre><code>C.pre = A;
C.next = A.next；
A.next.pre = C;
A.next = C;</code></pre><h4 id="18，谈谈HashSet的存储原理"><a href="#18，谈谈HashSet的存储原理" class="headerlink" title="18，谈谈HashSet的存储原理"></a>18，谈谈HashSet的存储原理</h4><p>HashSet的存储原理或者工作原理，主要是从如何保证唯一性来说起。</p>
<p>这里面主要有3个问题，需要回答？</p>
<p>第一，为什么要采用Hash算法？有什么优势，解决了什么问题？</p>
<p>第二，所谓哈希表是一张什么表？</p>
<p>第三，HashSet如何保证保存对象的唯一性？会经历一个什么样的运算过程？</p>
<p>大家可以先思考，晚些再补充答案！</p>
<p>首先，我们要明确一点，HashSet底层采用的是HashMap来实现存储，其值作为HashMap的key</p>
<pre><code>public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}</code></pre><p>具体关于hashmap的细节再说</p>
<p>第一，为什么要采用Hash算法？有什么优势，解决了什么问题？</p>
<p>解决的问题是唯一性存储数据，底层采用的是数组</p>
<p>当我们往数组放数据的时候，你如何判断是否唯一？</p>
<p>可以采用遍历的方式，逐个比较，但是这种效率低，尤其是数据很多的情况下</p>
<p>所以，为了解决这个效率低的问题，我们采用新的方式</p>
<p>采用hash算法，通过计算存储对象的hashcode，然后再跟数组长度-1做位运算，得到我们要存储在数组的哪个下标下，如果此时计算的位置没有其他元素，直接存储，不用比较。</p>
<p>此处，我们只会用到hashCode</p>
<p>但是随着元素的不断添加，就可能出现“哈希冲突”，不同的对象计算出来的hash值是相同的，这个时候，我们就需要比较，才需要用到equals方法</p>
<p>如果equals相同，则不插入，不相等，则形成链表</p>
<p>第二，所谓哈希表是一张什么表？</p>
<p>本质是一个数组，而且数组的元素是链表</p>
<p>JDK1.7的版本实现</p>
<p>JDK1.8做了优化</p>
<p>随着元素不断添加，链表可能会越来越长，会优化红黑树   </p>
<hr>
<h4 id="22-ArrayList-vs-Vector"><a href="#22-ArrayList-vs-Vector" class="headerlink" title="22. ArrayList vs Vector"></a>22. ArrayList vs Vector</h4><p>ArrayList： 线程不安全，效率高，常用</p>
<p>Vector: 线程安全的，效率低</p>
<p>我们看Vector的源码：</p>
<p>   <img data-sizes="auto" data-src="https://pic2.zhimg.com/v2-64837bba450a2a0cdcda96ae50bae445_b.jpg" alt="" class="lazyload"></p>
<hr>
<h4 id="23-Hashtable-amp-HashMap-ConcurentHashMap"><a href="#23-Hashtable-amp-HashMap-ConcurentHashMap" class="headerlink" title="23. Hashtable&amp;HashMap$ConcurentHashMap"></a>23. Hashtable&amp;HashMap$ConcurentHashMap</h4><ol>
<li>首先来看看其他几个相关的类</li>
</ol>
<p>Hashtable是线程安全的，但效率低</p>
<p>HashMap是线程不安全的，但效率高</p>
<p>如果有多个线程同时操作这一个HashMap，可能会出现线程不安全的情况，甚至出现死锁。</p>
<p>Collection.synchronizedMap(),工具类提供了同步包装器的方法，来返回具有线程安全的集合对象</p>
<p>性能依然有问题</p>
<pre><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {
  return new SynchronizedMap&lt;&gt;(m);  
}
//在这个类的内部方法实现上，也只是单纯加上了锁
pubic V put(K key, V value) {
  synchronized (mutex) {return m.put(key, value);}
}</code></pre><p>为解决这样的矛盾问题，所以JDK提供了并发包，来平衡这样的问题（java.util.concurrent）</p>
<ol start="2">
<li>ConcurentHashMap</li>
</ol>
<p>兼顾了线程安全和效率的问题</p>
<p>分析：HashTable锁了整段数据（用户操作是不同的数据段，依然需要等待）</p>
<p>解决方案：把数据分段，执行分段锁（分离锁），核心把锁的范围变小，这样出现并发冲突的概率就变小</p>
<p>在保存的时候，计算所存储的数据是属于哪一段，只锁当前这一段</p>
<ul>
<li>注意：分段锁（分离锁）是JDK1.8之前的一种的方案，JDK1.8之后做了优化。JDK1.7跟JDK1.8在ConcurrentHashMap的实现上存在以下区别：</li>
</ul>
<ol>
<li>数据结构</li>
</ol>
<p>JDK1.7采用链表的方式，而JDK1.8则采用链表+红黑树的方式</p>
<ol start="2">
<li>发生hash碰撞之后</li>
</ol>
<p>JDK1.7发生碰撞之后，会采用链表的方式来解决</p>
<p>JDK1.8发生碰撞之后，默认采用链表，但当链表的长度超过8，且数组容量超过64时，会转换为红黑树存储</p>
<ol start="3">
<li>保证并发安全</li>
</ol>
<p>JDK1.7采用分段锁的方式，而JDK1.8采用CAS和synchronized的组合模式</p>
<ol start="4">
<li>查询复杂度</li>
</ol>
<p>JDK1.7采用链表的方式，时间复杂度为O(n)，而JDK1.8在采用红黑树的方式时，时间复杂度为O(log(n))</p>
<p>题外话：</p>
<p>不过红黑树其实是一种兜底方案，因为当链表数量达到8个的时候，其发生的概率是千万分之几，所以作者考虑到这种极端情况下，需要用红黑树的方式来优化</p>
<p>三者在开发中如何选择：</p>
<ol>
<li>优先选择HashMap</li>
</ol>
<p>如果不是多个线程访问同一资源的情况，优选选择HashMap<br>局部变量，不是全局变量</p>
<ol start="2">
<li>是全局变量，多个线程共享访问<br>选择ConcurentHashMap</li>
</ol>
<h4 id="23-开发一个自己的栈，你会怎么写？"><a href="#23-开发一个自己的栈，你会怎么写？" class="headerlink" title="23. 开发一个自己的栈，你会怎么写？"></a>23. 开发一个自己的栈，你会怎么写？</h4><ol>
<li><p>数据结构用数组</p>
</li>
<li><p>采用先进后出</p>
</li>
<li><p>出栈 取末尾元素</p>
<p> array[array.length-1]</p>
</li>
<li><p>入栈 默认加到末尾，效率高</p>
<p> array[index++]= newObject;</p>
</li>
</ol>
<p>我们分析下JDK里面的Stack源码，会发现其实非常简单</p>
<p>首先，栈的特定是FILO(First in Last Out)</p>
<p>其次，底层的数据结构我们采用数组的方式</p>
<p>来，看几个关键性的源码，一目了然</p>
<p>存：</p>
<p><img data-sizes="auto" data-src="https://pic4.zhimg.com/v2-b4e97b3a0ae3c0b5fcf7d0ee4cffb1a7_b.jpg" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://pic3.zhimg.com/v2-4c7a884cf36dc1e2299457de80436082_b.jpg" alt="" class="lazyload"></p>
<p>取：</p>
<p><img data-sizes="auto" data-src="https://pic4.zhimg.com/v2-7358b2a3ff8ecaea6c75f3263618893f_b.jpg" alt="" class="lazyload"></p>
<p><img data-sizes="auto" data-src="https://pic4.zhimg.com/v2-7358b2a3ff8ecaea6c75f3263618893f_b.jpg" alt="" class="lazyload"></p>
<h4 id="双向链表怎么写？"><a href="#双向链表怎么写？" class="headerlink" title="双向链表怎么写？"></a>双向链表怎么写？</h4><p>双向链表有什么？</p>
<pre><code>class Node{
  Node pre;
  Node next;
  T date;
}</code></pre><p>前置节点，中间节点，后置节点</p>
<hr>
<h4 id="24-谈谈IO流的分类及选择"><a href="#24-谈谈IO流的分类及选择" class="headerlink" title="24. 谈谈IO流的分类及选择"></a>24. 谈谈IO流的分类及选择</h4><ol>
<li>分类</li>
</ol>
<p>按方向分：输入流，输出流</p>
<blockquote>
<p>注意：是站在程序的角度来看方向，程序读文件用输入流，程序写文件用输出流</p>
</blockquote>
<p>按读取的单位分：字节流，字符流</p>
<p>按处理方式分： 节点流，处理流</p>
<blockquote>
<p>比如，FileInputStream和BufferedInputStream(后者带有缓存区功能 byte[])</p>
</blockquote>
<p>IO的4大基类：InputStream,OutputStream,Reader,Writer</p>
<ol start="2">
<li>选择</li>
</ol>
<blockquote>
<p>字节流可以读取任何文件</p>
</blockquote>
<blockquote>
<p>读取文本文件的时候：选择字符流（假如有解析文件的内容的需求，比如逐行处理，则采用字符流，比如txt文件）</p>
</blockquote>
<blockquote>
<p>读取二进制文件的时候，选择字节流（视频，音频，doc，ppt）</p>
</blockquote>
<hr>
<h4 id="25-serialVersionUID的作用是什么"><a href="#25-serialVersionUID的作用是什么" class="headerlink" title="25. serialVersionUID的作用是什么"></a>25. serialVersionUID的作用是什么</h4><p>当执行序列号时，我们写对象到磁盘中，会根据当前这个类的结构生成一个版本号ID</p>
<p>但反序列化时，程序会比较磁盘中的序列化版本号ID跟当前的类结构生成的版本号是否一致，如果一致则反序列成功，否则，反序列化失败。</p>
<p>加上版本号，有助于当我们的类结构发生了变化，依然可以之前已经序列化的对象反序列化成功</p>
<p>新版本升级，兼容老版本</p>
<hr>
<h4 id="26-请描述下Java的异常体系"><a href="#26-请描述下Java的异常体系" class="headerlink" title="26. 请描述下Java的异常体系"></a>26. 请描述下Java的异常体系</h4><p><img data-sizes="auto" data-src="https://pic2.zhimg.com/v2-36ae97b8f5cfda5820465fc54c3530e9_b.jpg" alt="" class="lazyload"></p>
<p>Error是虚拟机内部错误</p>
<blockquote>
<p>栈内存溢出错误： StackOverflowError(递归，递归层次太多或递归没有结束)</p>
</blockquote>
<blockquote>
<p>堆内存溢出错误：OutOfMemoryError(堆创建了很多对象)</p>
</blockquote>
<p>Exception是我们的编写错误</p>
<blockquote>
<p>RuntimeException：也称LogicException</p>
</blockquote>
<blockquote>
<p>为什么编译器不会要求你去try catch处理？</p>
</blockquote>
<blockquote>
<p>本质是逻辑错误，比如空指针异常，这种问题是编译逻辑不严谨造成的</p>
</blockquote>
<blockquote>
<p>应该通过完善我们的代码编程逻辑，来解决问题</p>
</blockquote>
<p>非RuntimeException:</p>
<blockquote>
<p>编译器会要求我们try catch 或者throws处理</p>
</blockquote>
<blockquote>
<p>本质是客观因素造成的，比如</p>
</blockquote>
<blockquote>
<p>写了一个程序，自动阅卷，需要读取答案的路径（用户录入），用户可能录入是一个错误的路径，所以我们要提前预案，写好发生异常之后的处理方式，这也是java程序健壮性的一种体现</p>
</blockquote>
<hr>
<h4 id="27-罗列常见的5个运行时异常"><a href="#27-罗列常见的5个运行时异常" class="headerlink" title="27. 罗列常见的5个运行时异常"></a>27. 罗列常见的5个运行时异常</h4><p>此类异常，编译时没有提示做异常处理，因此通常此类异常的正确理解应该是“逻辑错误”</p>
<blockquote>
<p>算数异常，</p>
</blockquote>
<blockquote>
<p>空指针，</p>
</blockquote>
<blockquote>
<p>类型转换异常，</p>
</blockquote>
<blockquote>
<p>数组越界，</p>
</blockquote>
<blockquote>
<p>NumberformateException(数字格式异常，转换失败，比如“a12”就会转换失败)</p>
</blockquote>
<hr>
<h4 id="28-罗列常见的5个非运行时异常"><a href="#28-罗列常见的5个非运行时异常" class="headerlink" title="28. 罗列常见的5个非运行时异常"></a>28. 罗列常见的5个非运行时异常</h4><blockquote>
<p>IOException，</p>
</blockquote>
<blockquote>
<p>SQLException，</p>
</blockquote>
<blockquote>
<p>FileNotFoundException,</p>
</blockquote>
<blockquote>
<p>NoSuchFileException，</p>
</blockquote>
<blockquote>
<p>NoSuchMethodException</p>
</blockquote>
<hr>
<h4 id="29-throw-跟throws的区别"><a href="#29-throw-跟throws的区别" class="headerlink" title="29. throw 跟throws的区别"></a>29. throw 跟throws的区别</h4><blockquote>
<p>throw,作用于方法内，用于主动抛出异常</p>
</blockquote>
<blockquote>
<p>throws,作用于方法上的声明，声明该方法有可能会抛些某些异常</p>
</blockquote>
<p>针对项目中，异常的处理方式，我们一般采用层层往上抛，最终通过异常处理机制统一处理（展示异常页面，或返回统一的json信息），自定义 异常一般继承RunntimeException，我们去看看Hibernate等框架，他们的异常体系都是最终继承自RunntimeException</p>
<p>RunntimeException</p>
<p>框架:定义一系列规则</p>
<p>当你没有用对规则，就会报逻辑错误，比如忘加<br>@Serivce</p>
<hr>
<h4 id="30-一道关于try-catch-finally返回值的问题"><a href="#30-一道关于try-catch-finally返回值的问题" class="headerlink" title="30. 一道关于try catch finally返回值的问题"></a>30. 一道关于try catch finally返回值的问题</h4><p>以下这道题，在实际开发中，并不会这么写。</p>
<p>这个是面试官为了考察大家对finally的认识，而苦思冥想出来，我猜的。</p>
<p><img data-sizes="auto" data-src="https://pic3.zhimg.com/v2-3e8867ea1ca71f0aefa2c48680a2288e_b.jpg" alt="" class="lazyload"></p>
<p>结果是多少?你可以先想下。。。。。。。。</p>
<p>2,因为finally是无论如何都会执行，除非JVM关闭了</p>
<hr>
<h4 id="31-创建线程的方式"><a href="#31-创建线程的方式" class="headerlink" title="31. 创建线程的方式"></a>31. 创建线程的方式</h4><p>我们常说的方式有以下三种：</p>
<blockquote>
<p>继承Thread</p>
</blockquote>
<blockquote>
<p>实现Runable接口</p>
</blockquote>
<blockquote>
<p>实现Callable接口（可以获取线程执行之后的返回值）</p>
</blockquote>
<p>但实际后两种，更准确的理解是创建了一个可执行的任务，要采用多线程的方式执行，</p>
<p>还需要通过创建Thread对象来执行，比如：</p>
<pre><code>new Thread(new Runnable(){}).start()；</code></pre><p>这样的方式来执行。</p>
<p>在实际开发中，我们通常采用线程池的方式来完成Thread的创建，更好管理线程资源。</p>
<ol>
<li>如何正确启动线程</li>
</ol>
<pre><code>class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;：running.....&quot;);
    }
}

  public static void main(String[] args){
    MyThread thread = new MyThread();
    //正确启动线程的方式
    //thread.run();//调用方法并非开启新线程
    thread.start();
}</code></pre><p>步骤:</p>
<pre><code>1. 自定义类继承Thread类

2. 重写run()方法</code></pre><p>为什么重写run()?</p>
<blockquote>
<p>因为不是类中所有代码都要被线程执行, 为了区分哪些代码需要被执行, java提供了Thread类中的run()方法用来包含那些被线程执行的代码</p>
</blockquote>
<pre><code>3. 创建自定义类的对象

4. 启动线程对象</code></pre><p>用run()还是用start()?</p>
<p>区别:</p>
<blockquote>
<p>run()仅仅是封装被线程执行的方法, 直接调用时属于普通方法;</p>
</blockquote>
<blockquote>
<p>start()首先启动了线程, 然后再由jvm去调用该线程的run()方法.</p>
</blockquote>
<ol start="2">
<li>实现runnable只是创建了一个可执行任务，并不是一个线程</li>
</ol>
<pre><code>class MyTask implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;:running....&quot;);
    }
}

public static void main(String[] args){
        MyTask task = new MyTask();
        //task.start(); //并不能直接以线程的方式来启动
        //它表达的是一个任务，需要启动一个线程来执行
        new Thread(task).start();
}</code></pre><ol start="3">
<li>runnable vs callable</li>
</ol>
<pre><code>class MyTask2 implements Callable&lt;Boolean&gt;{
   @Override
   public Boolean call() throws Exception {
       return null;
   }
  }</code></pre><p>明确一点：本质上来说创建线程的方式就是继承Thread，就是线程池，内部也是创建好线程对象来执行任务。</p>
<hr>
<h3 id="32-一个普通main方法的执行，是单线程还是多线程？为什么？"><a href="#32-一个普通main方法的执行，是单线程还是多线程？为什么？" class="headerlink" title="32. 一个普通main方法的执行，是单线程还是多线程？为什么？"></a>32. 一个普通main方法的执行，是单线程还是多线程？为什么？</h3><p>因为Java中有一个重要的特性，叫垃圾回收机制，所以答案是多线程，这里面有两部分:</p>
<blockquote>
<p>主线程(用户线程),<br>垃圾回收线程GC(守护线程)</p>
</blockquote>
<p>同时存在。</p>
<h3 id="33-请描述线程的生命周期"><a href="#33-请描述线程的生命周期" class="headerlink" title="33. 请描述线程的生命周期"></a>33. 请描述线程的生命周期</h3><p>一图胜千言！</p>
<p><img data-sizes="auto" data-src="https://pic2.zhimg.com/v2-3640b7f86a072bc188199aa8bb76c271_b.jpg" alt="" class="lazyload"></p>
<p>上述的图有些简略，下面详细说明下，线程共有6种状态：</p>
<blockquote>
<p>new，<br>runnable，<br>blocked，<br>waiting，<br>timed waiting，<br>terminated</p>
</blockquote>
<ol>
<li><p>当进入synchronized同步代码块或同步方法时，且没有获取到锁，线程就进入了blocked状态，直到锁被释放，重新进入runnable状态</p>
</li>
<li><p>当线程调用wait()或者join时，线程都会进入到waiting状态，当调用notify或notifyAll时，或者join的线程执行结束后，会进入runnable状态</p>
</li>
<li><p>当线程调用sleep(time)，或者wait(time)时，进入timed waiting状态，当休眠时间结束后，或者调用notify或notifyAll时会重新runnable状态。</p>
</li>
<li><p>程序执行结束，线程进入terminated状态案例篇/**</p>
<ul>
<li>@author huangguizhao</li>
<li>测试线程的状态</li>
<li>/<br>public class ThreadStateTest {<br>public static void main(String[] args) throws InterruptedException {<pre><code>Thread thread = new Thread(new Task());
System.out.println(thread.getState());//NEW
thread.start();
System.out.println(thread.getState());//RUNNABLE
//保险起见，让当前主线程休眠下
Thread.sleep(10);
System.out.println(thread.getState());//terminated</code></pre>}<br>}<br>class Task implements Runnable{<br>@Override<br>public void run() {<pre><code>for (int i = 0; i &lt; 100; i++) {
    System.out.println(i);
}</code></pre>}<br>}public class ThreadStateTest {<br>public static void main(String[] args) throws InterruptedException {<pre><code>BlockTask task = new BlockTask();
Thread t1 = new Thread(task);
Thread t2 = new Thread(task);
t1.start();
t2.start();
//从严谨的角度来说，t1线程不一定会先执行，此处是假设t1先执行
System.out.println(t1.getState());//RUNNABLE
System.out.println(t2.getState());//BLOCKED
Thread.sleep(10);
System.out.println(t1.getState());//TIMED_WAITING
Thread.sleep(1000);
System.out.println(t1.getState());//WAITING</code></pre>}<br>}</li>
</ul>
</li>
</ol>
<p>class BlockTask implements Runnable{</p>
<pre><code>@Override
public void run() {
    synchronized (this){
        //另一个线程会进入block状态
        try {
            //目的是让线程进入waiting time状态
            Thread.sleep(1000);
            //进入waiting状态
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p>}</p>
<p>注意：blocked，waiting，timed waiting 我们都称为阻塞状态上述的就绪状态和运行状态，都表现为runnable状态</p>
<hr>
<h3 id="34，谈谈Sleep和wait的区别"><a href="#34，谈谈Sleep和wait的区别" class="headerlink" title="34，谈谈Sleep和wait的区别"></a>34，谈谈Sleep和wait的区别</h3><p>1，所属的类不同：</p>
<blockquote>
<p>sleep方法是定义在Thread上<br>wait方法是定义在Object上</p>
</blockquote>
<p>2，对于锁资源的处理方式不同</p>
<blockquote>
<p>sleep不会释放锁<br>wait会释放锁</p>
</blockquote>
<p>3，使用范围：</p>
<blockquote>
<p>sleep可以使用在任何代码块<br>wait必须在同步方法或同步代码块执行<br>4，与wait配套使用的方法</p>
</blockquote>
<p>void notify()<br>Wakes up a single thread that is waiting on this object’s monitor.<br>译：唤醒在此对象监视器上等待的单个线程<br>void notifyAll()<br>Wakes up all threads that are waiting on this object’s monitor.<br>译：唤醒在此对象监视器上等待的所有线程<br>void wait( )<br>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll( ) method for this object.<br>译：导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法<br>生命周期</p>
<p>1，当线程调用wait()或者join时，线程都会进入到waiting状态，当调用notify或notifyAll时，或者join的线程执行结束后，会进入runnable状态</p>
<p>2，当线程调用sleep(time)，或者wait(time)时，进入timed waiting状态，</p>
<p>最后，留下一个思考题，为什么wait要定义在Object中，而不定义在Thread中？</p>
<p>来解释下，我们回想下，在同步代码块中，我们说需要一个对象锁来实现多线程的互斥效果，也就是说，Java的锁是对象级别的，而不是线程级别的。</p>
<p>为什么wait必须写在同步代码块中？</p>
<p>原因是避免CPU切换到其他线程，而其他线程又提前执行了notify方法，那这样就达不到我们的预期（先wait再由其他线程来唤醒），所以需要一个同步锁来保护</p>
<hr>
<h3 id="36-谈谈你对线程安全的理解？"><a href="#36-谈谈你对线程安全的理解？" class="headerlink" title="36. 谈谈你对线程安全的理解？"></a>36. 谈谈你对线程安全的理解？</h3><p>如果这个是面试官直接问你的问题，你会怎么回答？</p>
<blockquote>
<p>一个专业的描述是，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的</p>
</blockquote>
<p>那么我们如何做到线程安全？</p>
<blockquote>
<p>实现线程安全的方式有多种，其中在源码中常见的方式是，采用synchronized关键字给代码块或方法加锁，比如StringBuffer</p>
</blockquote>
<blockquote>
<p>查看StringBuffer的源码，你会看到是这样的：</p>
</blockquote>
<p><img data-sizes="auto" data-src="https://pic1.zhimg.com/v2-4423b8f2855af708b62c1c167b432ca0_b.jpg" alt="" class="lazyload"></p>
<p>那么，我们开发中，如果需要拼接字符串，使用StringBuilder还是StringBuffer？</p>
<p>场景一：</p>
<p>如果是多个线程访问同一个资源，那么就需要上锁，才能保证数据的安全性。</p>
<p>这个时候如果使用的是非线程安全的对象，比如StringBuilder，那么就需要借助外力，给他加synchronized关键字。或者直接使用线程安全的对象StringBuffer</p>
<p>场景二：</p>
<p>如果每个线程访问的是各自的资源，那么就不需要考虑线程安全的问题，所以这个时候，我们可以放心使用非线程安全的对象，比如StringBuilder</p>
<p>比如在方法中，创建对象，来实现字符串的拼接。</p>
<p>看场景，如果我们是在方法中使用，那么建议在方法中创建StringBuilder，这时候相当是每个线程独立占有一个StringBuilder对象，不存在多线程共享一个资源的情况，所以我们可以安心使用，虽然StringBuilder本身不是线程安全的。</p>
<p>什么时候需要考虑线程安全？</p>
<p>1，多个线程访问同一个资源</p>
<p>2，资源是有状态的，比如我们上述讲的字符串拼接，这个时候数据是会有变化的</p>
<hr>
<h3 id="37-谈谈你对ThreadLocal的理解"><a href="#37-谈谈你对ThreadLocal的理解" class="headerlink" title="37. 谈谈你对ThreadLocal的理解"></a>37. 谈谈你对ThreadLocal的理解</h3><p>ThreadLocal解决了什么问题？内部源码是怎么样的？</p>
<p>作用：</p>
<p>为每个线程创建一个副本</p>
<p>实现在线程的上下文传递同一个对象，比如connection</p>
<p>第一个问题：证明ThreadLocal为每个线程创建一个变量副本</p>
<pre><code>public class ThreadLocalTest {

    private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void main(String[] args) throws InterruptedException {
        //开启多个线程来执行任务
        Task task = new Task();
        new Thread(task).start();
        Thread.sleep(10);
        new Thread(task).start();
    }

    static class Task implements Runnable{
        @Override
        public void run() {
            Long result = threadLocal.get();
            if(result == null){
                threadLocal.set(System.currentTimeMillis());
                System.out.println(Thread.currentThread().getName()+&quot;-&gt;&quot;+threadLocal.get());
            }
        }
    }

}</code></pre><p>输出的结果是不同的</p>
<p>问题二：为什么可以给每个线程保存一个不同的副本</p>
<p>那我们来分析源码</p>
<pre><code>Long result = threadLocal.get();

public T get() {
        //1.获取当前线程
        Thread t = Thread.currentThread();
        //2，获取到当前线程对应的map
        ThreadLocalMap map = getMap(t);

        if (map != null) {
            //3.以threadLocal为key，获取到entry
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                //4.获取对应entry的value，就是我们存放到里面的变量的副本
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }</code></pre><p>我们需要结合set方法的源码分析，才可以更好理解</p>
<pre><code>threadLocal.set(System.currentTimeMillis());

public void set(T value) {
        //1.获取到当前线程
        Thread t = Thread.currentThread();
        //2.获取当前线程对应的map
        ThreadLocalMap map = getMap(t);
        if (map != null)
            //3.往map存放一个键值对
            //this ThreadLocal
            //value 保存的副本
            map.set(this, value);
        else
            createMap(t, value);
    }</code></pre><p>所以，我们得到结论：</p>
<p>每个线程都会有对应的map，map来保存键值对。</p>
<p>问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？</p>
<p>比如：hibernate管理session，mybatis管理sqlsession，其内部都是采用ThreadLocal来实现的。</p>
<p>前提知识：不管是什么框架，最本质的操作都是基于JDBC，当我们需要跟数据库打交道的时候，都需要有一个connection。</p>
<p>那么，当我们需要在业务层实现事务控制时，该如何达到这个效果？</p>
<p>我们构建下代码如下：</p>
<pre><code>public class UserService {

    //省略接口的声明
    private UserDao userDao = new UserDao();
    private LogDao logDao = new LogDao();

    //事务的边界放在业务层
    //JDBC的封装，connection
    public void add(){
        userDao.add();
        logDao.add();
    }
}

public class UserDao {

    public void add(){
        System.out.println(&quot;UserDao add。。。&quot;);
        //创建connection对象
        //connection.commit();
        //connection.rollback();
    }
}

public class LogDao {

    public void add(){
        System.out.println(&quot;LogDao add。。。&quot;);
        //创建connection对象
        //connection.commit();
        //connection.rollback();
    }
}</code></pre><p>如果代码按上面的方式来管理connection，我们还可以保证service的事务控制吗？</p>
<p>这是不行的，假设第一个dao操作成功了，那么它就提交事务了，而第二个dao操作失败了，它回滚了事务，但不会影响到第一个dao的事务，因为上面这么写是两个独立的事务</p>
<p>那么怎么解决。</p>
<p>上面的根源就是两个dao操作的是不同的connection</p>
<p>所以，我们保证是同个connection即可</p>
<pre><code>//事务的边界放在业务层
//JDBC的封装，connection
public void add(){
    Connection connection = new Connection();
    userDao.add(connection);
    logDao.add(connection);
}上面的方式代码不够优雅public class ConnectionUtils {

    private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static Connection getConnection(){
        Connection connection = threadLocal.get();
        if(connection == null){
            connection = new Connection();
            threadLocal.set(connection);
        }
        return connection;
    }
}

public class UserDao {

    public void add(){
        System.out.println(&quot;UserDao add。。。&quot;);
        //创建connection对象
        //connection.commit();
        //connection.rollback();
        Connection connection = ConnectionUtils.getConnection();
        System.out.println(&quot;UserDao-&gt;&quot;+connection);
    }
}</code></pre><p>到此，我们可以保证两个dao操作的是同一个connection</p>
<hr>
<h3 id="38-我们谈谈类的加载机制"><a href="#38-我们谈谈类的加载机制" class="headerlink" title="38. 我们谈谈类的加载机制"></a>38. 我们谈谈类的加载机制</h3><h4 id="面试场景："><a href="#面试场景：" class="headerlink" title="面试场景："></a>面试场景：</h4><p>面试官第一问：</p>
<blockquote>
<p>请问，我现在编写一个类，类全名如下：java.lang.String,我们知道JDK也给我们听过了一个java.lang.String，那么，我们编写的这个String类能否替换到JDK默认提供，也就是说程序实际运行的时候，会加载我们的String还是JDK的String？为什么？</p>
</blockquote>
<p>如果，你无法确定？那么第二问：</p>
<blockquote>
<p>了解类的加载机制吗？知道JDK的类加载器吗？双亲委托机制说说看</p>
</blockquote>
<p>如果，你还不了解，那么我们聊聊今天的天气吧！</p>
<p>1, 首先，什么是类的加载机制？</p>
<p>JVM使用Java类的流程如下：</p>
<blockquote>
<ol>
<li>Java源文件—-编译—-&gt;class文件</li>
<li>类加载器ClassLoader会读取这个.class文件，并将其转化为java.lang.Class的实例。有了该实例，JVM就可以使用他来创建对象，调用方法等操作了。那么ClassLoader是以一种什么机制来加载Class的？这就是我们要谈的类的加载机制！</li>
</ol>
</blockquote>
<p>2，搞清楚这个问题，首先要知道，我们用到的Class文件都有哪些来源？</p>
<blockquote>
<p> 1，Java内部自带的核心类，位于$JAVA_HOME/jre/lib，其中最著名的莫过于rt.jar<br> 2. Java的扩展类，位于$JAVA_HOME/jre/lib/ext目录下<br>3. 我们自己开发的类或项目开发用到的第三方jar包，位于我们项目的目录下，比如WEB-INF/lib目录</p>
</blockquote>
<p>3，那么，针对这些Class，JDK是怎么分工的？谁来加载这些Class？</p>
<blockquote>
<p>针对不同的来源，Java分了不同的ClassLoader来加载</p>
<ol>
<li>Java核心类，这些Java运行的基础类，由一个名为BootstrapClassLoader加载器负责加载。这个类加载器被称为“根加载器或引导加载器”注意：BootstrapClassLoader不继承ClassLoader，是由JVM内部实现。法力无边，所以你通过java程序访问不到，得到的是null。</li>
<li>Java扩展类，是由ExtClassLoader负责加载，被称为“扩展类加载器”。</li>
<li>项目中编写的类，是由AppClassLoader来负责加载，被称为“系统类加载器”。</li>
</ol>
</blockquote>
<p>4, 那凭什么，我就知道这个类应该由老大BootStrapClassLoader来加载？</p>
<p>这里面就要基于双亲委托机制？</p>
<blockquote>
<p>所谓双亲委托机制，就是加载一个类，会先获取到一个系统类加载器AppClassLoader的实例，然后往上层层请求，先由BootstarpClassLoader去加载，如果BootStrapClassLoader发现没有，再下发给ExtClassLoader去加载，还是没有，才由AppClassLoader去加载。如果还是没有，则报错</p>
</blockquote>
<p>5，所以，上述问题的答案你清楚了吗？</p>
<blockquote>
<p>JDK提供java.lang.String类，默认在rt.jar这个包里面，所以，默认会由BootstarpClassLoader加载，所以，我们自己编写的java.lang.String，都没有机会被加载到</p>
</blockquote>
<p>6，给两段程序看看，类加载器的关系</p>
<p>案例1：创建一个自己的类，然后打印其类加载器</p>
<pre><code>public class ClassLoaderTest {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&lt;?&gt; clazz = Class.forName(&quot;com.huangguizhao.thread.client.Programmer&quot;);
        ClassLoader classLoader = clazz.getClassLoader();
        System.out.println(classLoader.getClass().getSimpleName());
    }
}</code></pre><p>案例2：打印其双亲类加载器信息</p>
<pre><code>while(classLoader.getParent() != null){
       classLoader = classLoader.getParent();
       System.out.println(&quot;--&gt;&quot;+classLoader.getClass().getSimpleName());
}</code></pre><hr>
<h3 id="42，谈谈Ajax的工作原理"><a href="#42，谈谈Ajax的工作原理" class="headerlink" title="42，谈谈Ajax的工作原理"></a>42，谈谈Ajax的工作原理</h3><p>谈这个问题的关键三要素，异步交互，XMLHttpRequest对象，回调函数。</p>
<p>下面，看图，传统模式跟Ajax工作模式的对比：</p>
<p><img data-sizes="auto" data-src="https://pic1.zhimg.com/v2-744604fac1b53e491e63a1a4c1f3ba34_b.jpg" alt="" class="lazyload"></p>
<p>早期，预计是以XML为主要的传输数据格式，所以Ajax的最后一个字母就是代表XML的意思，不过现在基本是json为主。</p>
<hr>
<h3 id="43-谈谈JavaScript的原型机制"><a href="#43-谈谈JavaScript的原型机制" class="headerlink" title="43, 谈谈JavaScript的原型机制"></a>43, 谈谈JavaScript的原型机制</h3><p>JavaScript的原型有一个关键的作用就是来扩展原有类的特性，比如下面这段代码，给String扩展了hello方法。很多框架就是采用了这种方式来进行扩展，从而让框架更易用。</p>
<pre><code>var str = &quot;abc&quot;;
String.prototype.hello = function(){
     alert(&quot;通过原型方式来扩展原有的类的方法或属性&quot;)；
}

str.hello();</code></pre><hr>
<h3 id="44-谈谈"><a href="#44-谈谈" class="headerlink" title="44. 谈谈"></a>44. 谈谈</h3><hr>
<h3 id="45-描述JSP和Servlet的区别"><a href="#45-描述JSP和Servlet的区别" class="headerlink" title="45. 描述JSP和Servlet的区别"></a>45. 描述JSP和Servlet的区别</h3><p>MVC是什么？</p>
<blockquote>
<p>M:模型<br>V:视图<br>C: 控制器</p>
</blockquote>
<p>技术角度</p>
<blockquote>
<p>JSP本质就是一个Servlet<br>JSP的工作原理：JSP-&gt;翻译-&gt;Servlet(java)-&gt;编译-&gt;Class（最终跑的文件）</p>
</blockquote>
<p>应用的角度：</p>
<blockquote>
<p>JSP=HTML+Java<br>Servlet=Java+HTML<br>各取所长，JSP的特点在于实现视图，Servlet的特点在于实现控制逻辑</p>
</blockquote>
<h3 id="48-描述"><a href="#48-描述" class="headerlink" title="48, 描述"></a>48, 描述</h3>
  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>零点坠落<br>
    <strong>本文链接：</strong><a href="http://yoursite.com/2021/01/03/Interview100.html/" title="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;01&#x2F;03&#x2F;Interview100.html&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;01&#x2F;03&#x2F;Interview100.html&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'ZmingWill.github.io',
        owner: 'ZmingWill',
        admin: 'ZmingWill'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1655133146715"></script>
  





</body>

</html>
